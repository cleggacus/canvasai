import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import { print } from 'graphql'
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  DateTime: any;
  JSON: any;
  URL: any;
};

export type Account = LegacyIdInterface & Node & {
  __typename?: 'Account';
  /** legacy canvas id */
  _id: Scalars['ID'];
  accountDomainLookups?: Maybe<Array<AccountDomainLookup>>;
  accountDomains?: Maybe<Array<AccountDomain>>;
  coursesConnection?: Maybe<CourseConnection>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  outcomeCalculationMethod?: Maybe<OutcomeCalculationMethod>;
  outcomeProficiency?: Maybe<OutcomeProficiency>;
  parentAccountsConnection: AccountConnection;
  proficiencyRatingsConnection?: Maybe<ProficiencyRatingConnection>;
  rootOutcomeGroup: LearningOutcomeGroup;
  sisId?: Maybe<Scalars['String']>;
  subAccountsConnection?: Maybe<AccountConnection>;
};


export type AccountCoursesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type AccountParentAccountsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type AccountProficiencyRatingsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type AccountSubAccountsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Account. */
export type AccountConnection = {
  __typename?: 'AccountConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Account>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type AccountDomain = LegacyIdInterface & Timestamped & {
  __typename?: 'AccountDomain';
  /** legacy canvas id */
  _id: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  host: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AccountDomainLookup = LegacyIdInterface & Timestamped & {
  __typename?: 'AccountDomainLookup';
  /** legacy canvas id */
  _id: Scalars['ID'];
  accountDomain?: Maybe<AccountDomain>;
  authenticationProvider?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

/** An edge in a connection. */
export type AccountEdge = {
  __typename?: 'AccountEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Account>;
};

/** Autogenerated input type of AddConversationMessage */
export type AddConversationMessageInput = {
  attachmentIds?: InputMaybe<Array<Scalars['ID']>>;
  body: Scalars['String'];
  contextCode?: InputMaybe<Scalars['String']>;
  conversationId: Scalars['ID'];
  includedMessages?: InputMaybe<Array<Scalars['ID']>>;
  mediaCommentId?: InputMaybe<Scalars['ID']>;
  mediaCommentType?: InputMaybe<Scalars['String']>;
  recipients: Array<Scalars['String']>;
  userNote?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of AddConversationMessage */
export type AddConversationMessagePayload = {
  __typename?: 'AddConversationMessagePayload';
  conversationMessage?: Maybe<ConversationMessage>;
  errors?: Maybe<Array<ValidationError>>;
};

/** A list of students that an `AssignmentOverride` applies to */
export type AdhocStudents = {
  __typename?: 'AdhocStudents';
  students?: Maybe<Array<User>>;
};

export type AnonymousUser = {
  __typename?: 'AnonymousUser';
  avatarUrl?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  shortName: Scalars['String'];
};

export type AssessmentRequest = LegacyIdInterface & Timestamped & {
  __typename?: 'AssessmentRequest';
  /** legacy canvas id */
  _id: Scalars['ID'];
  anonymizedUser?: Maybe<User>;
  anonymousId?: Maybe<Scalars['String']>;
  assetSubmissionType?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user: User;
  workflowState: Scalars['String'];
};

/** The type of assessment */
export enum AssessmentType {
  Grading = 'grading',
  PeerReview = 'peer_review',
  ProvisionalGrade = 'provisional_grade'
}

export type AssetString = {
  assetString?: Maybe<Scalars['String']>;
};

export type Assignment = LegacyIdInterface & ModuleItemInterface & Node & Timestamped & {
  __typename?: 'Assignment';
  /** legacy canvas id */
  _id: Scalars['ID'];
  allowGoogleDocsSubmission?: Maybe<Scalars['Boolean']>;
  /** The number of submission attempts a student can make for this assignment. null implies unlimited. */
  allowedAttempts?: Maybe<Scalars['Int']>;
  /** permitted uploaded file extensions (e.g. ['doc', 'xls', 'txt']) */
  allowedExtensions?: Maybe<Array<Scalars['String']>>;
  anonymizeStudents?: Maybe<Scalars['Boolean']>;
  anonymousGrading?: Maybe<Scalars['Boolean']>;
  anonymousInstructorAnnotations?: Maybe<Scalars['Boolean']>;
  assessmentRequestsForCurrentUser?: Maybe<Array<AssessmentRequest>>;
  assignmentGroup?: Maybe<AssignmentGroup>;
  assignmentOverrides?: Maybe<AssignmentOverrideConnection>;
  canDuplicate?: Maybe<Scalars['Boolean']>;
  canUnpublish?: Maybe<Scalars['Boolean']>;
  course?: Maybe<Course>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  discussion?: Maybe<Discussion>;
  /** when this assignment is due */
  dueAt?: Maybe<Scalars['DateTime']>;
  dueDateRequired?: Maybe<Scalars['Boolean']>;
  expectsExternalSubmission?: Maybe<Scalars['Boolean']>;
  expectsSubmission?: Maybe<Scalars['Boolean']>;
  /** If this is a group assignment, boolean flag indicating whether or not students will be graded individually. */
  gradeGroupStudentsIndividually?: Maybe<Scalars['Boolean']>;
  gradingType?: Maybe<GradingType>;
  groupCategoryId?: Maybe<Scalars['Int']>;
  groupSet?: Maybe<GroupSet>;
  /** returns submissions grouped to one submission object per group */
  groupSubmissionsConnection?: Maybe<SubmissionConnection>;
  /** If true, the assignment has been submitted to by at least one student */
  hasSubmittedSubmissions?: Maybe<Scalars['Boolean']>;
  htmlUrl?: Maybe<Scalars['URL']>;
  id: Scalars['ID'];
  inClosedGradingPeriod?: Maybe<Scalars['Boolean']>;
  /** the lock date (assignment is locked after this date) */
  lockAt?: Maybe<Scalars['DateTime']>;
  lockInfo?: Maybe<LockInfo>;
  moderatedGrading?: Maybe<ModeratedGrading>;
  modules?: Maybe<Array<Module>>;
  name?: Maybe<Scalars['String']>;
  needsGradingCount?: Maybe<Scalars['Int']>;
  nonDigitalSubmission?: Maybe<Scalars['Boolean']>;
  /** If true, the assignment will be omitted from the student's final grade */
  omitFromFinalGrade?: Maybe<Scalars['Boolean']>;
  /**
   * specifies that this assignment is only assigned to students for whom an
   *        `AssignmentOverride` applies.
   */
  onlyVisibleToOverrides: Scalars['Boolean'];
  originalityReportVisibility?: Maybe<Scalars['String']>;
  peerReviews?: Maybe<PeerReviews>;
  /** the assignment is out of this many points */
  pointsPossible?: Maybe<Scalars['Float']>;
  /** determines the order this assignment is displayed in in its assignment group */
  position?: Maybe<Scalars['Int']>;
  postPolicy?: Maybe<PostPolicy>;
  /** present if Sync Grades to SIS feature is enabled */
  postToSis?: Maybe<Scalars['Boolean']>;
  quiz?: Maybe<Quiz>;
  rubric?: Maybe<Rubric>;
  rubricAssociation?: Maybe<RubricAssociation>;
  sisId?: Maybe<Scalars['String']>;
  state: AssignmentState;
  submissionTypes?: Maybe<Array<SubmissionType>>;
  /** submissions for this assignment */
  submissionsConnection?: Maybe<SubmissionConnection>;
  submissionsDownloads?: Maybe<Scalars['Int']>;
  timeZoneEdited?: Maybe<Scalars['String']>;
  /** the unlock date (assignment is unlocked after this date) */
  unlockAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};


export type AssignmentAssignmentOverridesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type AssignmentDueAtArgs = {
  applyOverrides?: InputMaybe<Scalars['Boolean']>;
};


export type AssignmentGroupSubmissionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<SubmissionSearchFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SubmissionSearchOrder>>;
};


export type AssignmentLockAtArgs = {
  applyOverrides?: InputMaybe<Scalars['Boolean']>;
};


export type AssignmentSubmissionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<SubmissionSearchFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SubmissionSearchOrder>>;
};


export type AssignmentUnlockAtArgs = {
  applyOverrides?: InputMaybe<Scalars['Boolean']>;
};

/** The connection type for Assignment. */
export type AssignmentConnection = {
  __typename?: 'AssignmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AssignmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Assignment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AssignmentEdge = {
  __typename?: 'AssignmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Assignment>;
};

export type AssignmentFilter = {
  /**
   * only return assignments for the given grading period. Defaults to
   * the current grading period. Pass `null` to return all assignments
   * (irrespective of the assignment's grading period)
   *
   */
  gradingPeriodId?: InputMaybe<Scalars['ID']>;
};

export type AssignmentGroup = AssignmentsConnectionInterface & LegacyIdInterface & Node & Timestamped & {
  __typename?: 'AssignmentGroup';
  /** legacy canvas id */
  _id: Scalars['ID'];
  /**
   * returns a list of assignments.
   *
   * **NOTE**: for courses with grading periods, this will only return grading
   * periods in the current course; see `AssignmentFilter` for more info.
   * In courses with grading periods that don't have students, it is necessary
   * to *not* filter by grading period to list assignments.
   *
   */
  assignmentsConnection?: Maybe<AssignmentConnection>;
  createdAt?: Maybe<Scalars['DateTime']>;
  /** grades for this assignment group */
  gradesConnection?: Maybe<GradesConnection>;
  groupWeight?: Maybe<Scalars['Float']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  position?: Maybe<Scalars['Int']>;
  rules?: Maybe<AssignmentGroupRules>;
  sisId?: Maybe<Scalars['String']>;
  state: AssignmentGroupState;
  updatedAt?: Maybe<Scalars['DateTime']>;
};


export type AssignmentGroupAssignmentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<AssignmentFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type AssignmentGroupGradesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<GradesEnrollmentFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for AssignmentGroup. */
export type AssignmentGroupConnection = {
  __typename?: 'AssignmentGroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AssignmentGroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AssignmentGroup>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type AssignmentGroupEdge = {
  __typename?: 'AssignmentGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AssignmentGroup>;
};

export type AssignmentGroupRules = {
  __typename?: 'AssignmentGroupRules';
  /** The highest N assignments are not included in grade calculations */
  dropHighest?: Maybe<Scalars['Int']>;
  /** The lowest N assignments are not included in grade calculations */
  dropLowest?: Maybe<Scalars['Int']>;
  neverDrop?: Maybe<Array<Assignment>>;
};

/** States that Assignment Group can be in */
export enum AssignmentGroupState {
  Available = 'available',
  Deleted = 'deleted'
}

export type AssignmentModeratedGradingUpdate = {
  enabled?: InputMaybe<Scalars['Boolean']>;
  finalGraderId?: InputMaybe<Scalars['ID']>;
  graderCommentsVisibleToGraders?: InputMaybe<Scalars['Boolean']>;
  graderCount?: InputMaybe<Scalars['Int']>;
  graderNamesVisibleToFinalGrader?: InputMaybe<Scalars['Boolean']>;
  gradersAnonymousToGraders?: InputMaybe<Scalars['Boolean']>;
};

export type AssignmentOverride = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'AssignmentOverride';
  /** legacy canvas id */
  _id: Scalars['ID'];
  allDay?: Maybe<Scalars['Boolean']>;
  assignment?: Maybe<Assignment>;
  createdAt?: Maybe<Scalars['DateTime']>;
  dueAt?: Maybe<Scalars['DateTime']>;
  /** ID of the object. */
  id: Scalars['ID'];
  lockAt?: Maybe<Scalars['DateTime']>;
  /** This object specifies what students this override applies to */
  set?: Maybe<AssignmentOverrideSet>;
  title?: Maybe<Scalars['String']>;
  unlockAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

/** The connection type for AssignmentOverride. */
export type AssignmentOverrideConnection = {
  __typename?: 'AssignmentOverrideConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AssignmentOverrideEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AssignmentOverride>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type AssignmentOverrideCreateOrUpdate = {
  dueAt?: InputMaybe<Scalars['DateTime']>;
  groupId?: InputMaybe<Scalars['ID']>;
  id?: InputMaybe<Scalars['ID']>;
  lockAt?: InputMaybe<Scalars['DateTime']>;
  sectionId?: InputMaybe<Scalars['ID']>;
  studentIds?: InputMaybe<Array<Scalars['ID']>>;
  unlockAt?: InputMaybe<Scalars['DateTime']>;
};

/** An edge in a connection. */
export type AssignmentOverrideEdge = {
  __typename?: 'AssignmentOverrideEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<AssignmentOverride>;
};

/** Objects that can be assigned overridden dates */
export type AssignmentOverrideSet = AdhocStudents | Group | Noop | Section;

export type AssignmentPeerReviewsUpdate = {
  anonymousReviews?: InputMaybe<Scalars['Boolean']>;
  automaticReviews?: InputMaybe<Scalars['Boolean']>;
  count?: InputMaybe<Scalars['Int']>;
  dueAt?: InputMaybe<Scalars['DateTime']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  intraReviews?: InputMaybe<Scalars['Boolean']>;
};

/** States that an Assignment can be in */
export enum AssignmentState {
  Deleted = 'deleted',
  Duplicating = 'duplicating',
  FailToImport = 'fail_to_import',
  FailedToDuplicate = 'failed_to_duplicate',
  FailedToMigrate = 'failed_to_migrate',
  Importing = 'importing',
  Migrating = 'migrating',
  Published = 'published',
  Unpublished = 'unpublished'
}

export type AssignmentsConnectionInterface = {
  /**
   * returns a list of assignments.
   *
   * **NOTE**: for courses with grading periods, this will only return grading
   * periods in the current course; see `AssignmentFilter` for more info.
   * In courses with grading periods that don't have students, it is necessary
   * to *not* filter by grading period to list assignments.
   *
   */
  assignmentsConnection?: Maybe<AssignmentConnection>;
};


export type AssignmentsConnectionInterfaceAssignmentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<AssignmentFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type AuditLogs = {
  __typename?: 'AuditLogs';
  /** A list of all recent graphql mutations run on the specified object */
  mutationLogs?: Maybe<MutationLogConnection>;
};


export type AuditLogsMutationLogsArgs = {
  after?: InputMaybe<Scalars['String']>;
  assetString: Scalars['String'];
  before?: InputMaybe<Scalars['String']>;
  endTime?: InputMaybe<Scalars['DateTime']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  startTime?: InputMaybe<Scalars['DateTime']>;
};

/** Determines if/how a leader is chosen for each group */
export enum AutoLeaderPolicy {
  /** the first student assigned to the group is the leader */
  First = 'first',
  /** a leader is chosen at random */
  Random = 'random'
}

/** Comment bank items */
export type CommentBankItem = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'CommentBankItem';
  /** legacy canvas id */
  _id: Scalars['ID'];
  comment: Scalars['String'];
  courseId: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  updatedAt?: Maybe<Scalars['DateTime']>;
  userId: Scalars['ID'];
};

/** The connection type for CommentBankItem. */
export type CommentBankItemConnection = {
  __typename?: 'CommentBankItemConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommentBankItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CommentBankItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CommentBankItemEdge = {
  __typename?: 'CommentBankItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<CommentBankItem>;
};

export type CommunicationChannel = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'CommunicationChannel';
  /** legacy canvas id */
  _id: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  notificationPolicies?: Maybe<Array<NotificationPolicy>>;
  notificationPolicyOverrides?: Maybe<Array<NotificationPolicy>>;
  path?: Maybe<Scalars['String']>;
  pathType?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};


export type CommunicationChannelNotificationPoliciesArgs = {
  contextType?: InputMaybe<NotificationPreferencesContextType>;
};


export type CommunicationChannelNotificationPolicyOverridesArgs = {
  accountId?: InputMaybe<Scalars['ID']>;
  contextType: NotificationPreferencesContextType;
  courseId?: InputMaybe<Scalars['ID']>;
};

/** An edge in a connection. */
export type ContentTag = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'ContentTag';
  /** legacy canvas id */
  _id: Scalars['ID'];
  canUnlink?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  group?: Maybe<LearningOutcomeGroup>;
  id: Scalars['ID'];
  /** The item at the end of the edge. */
  node?: Maybe<ContentTagContent>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

/** The connection type for ContentTagContent. */
export type ContentTagConnection = {
  __typename?: 'ContentTagConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContentTag>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ContentTagContent>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** Content of a Content Tag */
export type ContentTagContent = LearningOutcome;

export type Conversation = Node & {
  __typename?: 'Conversation';
  /** legacy canvas id */
  _id: Scalars['ID'];
  canReply?: Maybe<Scalars['Boolean']>;
  contextId?: Maybe<Scalars['ID']>;
  contextName?: Maybe<Scalars['String']>;
  contextType?: Maybe<Scalars['String']>;
  conversationMessagesConnection?: Maybe<ConversationMessageConnection>;
  conversationParticipantsConnection?: Maybe<ConversationParticipantConnection>;
  id: Scalars['ID'];
  isPrivate?: Maybe<Scalars['Boolean']>;
  subject?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};


export type ConversationConversationMessagesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  createdBefore?: InputMaybe<Scalars['DateTime']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  participants?: InputMaybe<Array<Scalars['ID']>>;
};


export type ConversationConversationParticipantsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type ConversationMessage = {
  __typename?: 'ConversationMessage';
  /** legacy canvas id */
  _id: Scalars['ID'];
  attachmentsConnection?: Maybe<FileConnection>;
  author?: Maybe<User>;
  body: Scalars['String'];
  conversationId: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  mediaComment?: Maybe<MediaObject>;
  recipients: Array<User>;
};


export type ConversationMessageAttachmentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for ConversationMessage. */
export type ConversationMessageConnection = {
  __typename?: 'ConversationMessageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ConversationMessageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ConversationMessage>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ConversationMessageEdge = {
  __typename?: 'ConversationMessageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ConversationMessage>;
};

export type ConversationParticipant = {
  __typename?: 'ConversationParticipant';
  /** legacy canvas id */
  _id: Scalars['ID'];
  conversation: Conversation;
  id: Scalars['ID'];
  label?: Maybe<Scalars['String']>;
  messages?: Maybe<ConversationMessageConnection>;
  subscribed: Scalars['Boolean'];
  updatedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<User>;
  userId: Scalars['ID'];
  workflowState: Scalars['String'];
};


export type ConversationParticipantMessagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for ConversationParticipant. */
export type ConversationParticipantConnection = {
  __typename?: 'ConversationParticipantConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ConversationParticipantEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ConversationParticipant>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ConversationParticipantEdge = {
  __typename?: 'ConversationParticipantEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ConversationParticipant>;
};

export type Course = AssetString & AssignmentsConnectionInterface & LegacyIdInterface & Node & Timestamped & {
  __typename?: 'Course';
  /** legacy canvas id */
  _id: Scalars['ID'];
  account?: Maybe<Account>;
  allowFinalGradeOverride?: Maybe<Scalars['Boolean']>;
  assetString?: Maybe<Scalars['String']>;
  assignmentGroupsConnection?: Maybe<AssignmentGroupConnection>;
  /**
   * PostPolicies for assignments within a course
   *
   */
  assignmentPostPolicies?: Maybe<PostPolicyConnection>;
  /**
   * returns a list of assignments.
   *
   * **NOTE**: for courses with grading periods, this will only return grading
   * periods in the current course; see `AssignmentFilter` for more info.
   * In courses with grading periods that don't have students, it is necessary
   * to *not* filter by grading period to list assignments.
   *
   */
  assignmentsConnection?: Maybe<AssignmentConnection>;
  /** course short name */
  courseCode?: Maybe<Scalars['String']>;
  courseNickname?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  enrollmentsConnection?: Maybe<EnrollmentConnection>;
  externalToolsConnection?: Maybe<ExternalToolConnection>;
  gradingPeriodsConnection?: Maybe<GradingPeriodConnection>;
  /**
   * Project group sets for this course.
   *
   */
  groupSetsConnection?: Maybe<GroupSetConnection>;
  groupsConnection?: Maybe<GroupConnection>;
  id: Scalars['ID'];
  /**
   * Returns a URL for the course image (this is the image used on dashboard
   * course cards)
   *
   */
  imageUrl?: Maybe<Scalars['URL']>;
  modulesConnection?: Maybe<ModuleConnection>;
  name: Scalars['String'];
  outcomeAlignmentStats?: Maybe<CourseOutcomeAlignmentStats>;
  outcomeCalculationMethod?: Maybe<OutcomeCalculationMethod>;
  outcomeProficiency?: Maybe<OutcomeProficiency>;
  /** returns permission information for the current user in this course */
  permissions?: Maybe<CoursePermissions>;
  /** A course-specific post policy */
  postPolicy?: Maybe<PostPolicy>;
  rootOutcomeGroup: LearningOutcomeGroup;
  sectionsConnection?: Maybe<SectionConnection>;
  sisId?: Maybe<Scalars['String']>;
  state: CourseWorkflowState;
  /** all the submissions for assignments in this course */
  submissionsConnection?: Maybe<SubmissionConnection>;
  syllabusBody?: Maybe<Scalars['String']>;
  term?: Maybe<Term>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  usersConnection?: Maybe<UserConnection>;
};


export type CourseAssignmentGroupsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CourseAssignmentPostPoliciesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CourseAssignmentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<AssignmentFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CourseEnrollmentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<EnrollmentFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CourseExternalToolsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<ExternalToolFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CourseGradingPeriodsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CourseGroupSetsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CourseGroupsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CourseModulesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CourseSectionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type CourseSubmissionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<SubmissionFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SubmissionOrderCriteria>>;
  studentIds?: InputMaybe<Array<Scalars['ID']>>;
};


export type CourseUsersConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<CourseUsersFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  userIds?: InputMaybe<Array<Scalars['ID']>>;
};

/** The connection type for Course. */
export type CourseConnection = {
  __typename?: 'CourseConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CourseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Course>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CourseEdge = {
  __typename?: 'CourseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Course>;
};

/** Users in a course can be returned based on these enrollment states */
export enum CourseFilterableEnrollmentState {
  Active = 'active',
  Completed = 'completed',
  CreationPending = 'creation_pending',
  Inactive = 'inactive',
  Invited = 'invited',
  Rejected = 'rejected'
}

/** Users in a course can be returned based on these enrollment types */
export enum CourseFilterableEnrollmentType {
  DesignerEnrollment = 'DesignerEnrollment',
  ObserverEnrollment = 'ObserverEnrollment',
  StudentEnrollment = 'StudentEnrollment',
  StudentViewEnrollment = 'StudentViewEnrollment',
  TaEnrollment = 'TaEnrollment',
  TeacherEnrollment = 'TeacherEnrollment'
}

export type CourseOutcomeAlignmentStats = {
  __typename?: 'CourseOutcomeAlignmentStats';
  alignedArtifacts?: Maybe<Scalars['Int']>;
  alignedOutcomes?: Maybe<Scalars['Int']>;
  artifactAlignments?: Maybe<Scalars['Int']>;
  totalAlignments?: Maybe<Scalars['Int']>;
  totalArtifacts?: Maybe<Scalars['Int']>;
  totalOutcomes?: Maybe<Scalars['Int']>;
};

export type CoursePermissions = {
  __typename?: 'CoursePermissions';
  becomeUser?: Maybe<Scalars['Boolean']>;
  manageGrades?: Maybe<Scalars['Boolean']>;
  sendMessages?: Maybe<Scalars['Boolean']>;
  viewAllGrades?: Maybe<Scalars['Boolean']>;
  viewAnalytics?: Maybe<Scalars['Boolean']>;
};

export type CourseUsersFilter = {
  /**
   * only return users with the given enrollment state. defaults
   * to `invited`, `creation_pending`, `active`
   *
   */
  enrollmentStates?: InputMaybe<Array<CourseFilterableEnrollmentState>>;
  /** Only return users with the specified enrollment types */
  enrollmentTypes?: InputMaybe<Array<CourseFilterableEnrollmentType>>;
  /** only include users with the given ids */
  userIds?: InputMaybe<Array<Scalars['ID']>>;
};

/** States that Courses can be in */
export enum CourseWorkflowState {
  Available = 'available',
  Claimed = 'claimed',
  Completed = 'completed',
  Created = 'created',
  Deleted = 'deleted'
}

/** Autogenerated input type of CreateAccountDomainLookup */
export type CreateAccountDomainLookupInput = {
  accountDomainId: Scalars['ID'];
  authenticationProvider?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
};

/** Autogenerated return type of CreateAccountDomainLookup */
export type CreateAccountDomainLookupPayload = {
  __typename?: 'CreateAccountDomainLookupPayload';
  accountDomainLookup?: Maybe<AccountDomainLookup>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of CreateAssignment */
export type CreateAssignmentInput = {
  allowedAttempts?: InputMaybe<Scalars['Int']>;
  allowedExtensions?: InputMaybe<Array<Scalars['String']>>;
  /** requires anonymous_marking course feature to be set to true */
  anonymousGrading?: InputMaybe<Scalars['Boolean']>;
  anonymousInstructorAnnotations?: InputMaybe<Scalars['Boolean']>;
  assignmentGroupId?: InputMaybe<Scalars['ID']>;
  assignmentOverrides?: InputMaybe<Array<AssignmentOverrideCreateOrUpdate>>;
  courseId: Scalars['ID'];
  description?: InputMaybe<Scalars['String']>;
  dueAt?: InputMaybe<Scalars['DateTime']>;
  gradeGroupStudentsIndividually?: InputMaybe<Scalars['Boolean']>;
  gradingType?: InputMaybe<GradingType>;
  groupCategoryId?: InputMaybe<Scalars['ID']>;
  groupSetId?: InputMaybe<Scalars['ID']>;
  lockAt?: InputMaybe<Scalars['DateTime']>;
  moderatedGrading?: InputMaybe<AssignmentModeratedGradingUpdate>;
  moduleIds?: InputMaybe<Array<Scalars['ID']>>;
  name: Scalars['String'];
  omitFromFinalGrade?: InputMaybe<Scalars['Boolean']>;
  onlyVisibleToOverrides?: InputMaybe<Scalars['Boolean']>;
  peerReviews?: InputMaybe<AssignmentPeerReviewsUpdate>;
  pointsPossible?: InputMaybe<Scalars['Float']>;
  position?: InputMaybe<Scalars['Int']>;
  postToSis?: InputMaybe<Scalars['Boolean']>;
  state?: InputMaybe<AssignmentState>;
  submissionTypes?: InputMaybe<Array<SubmissionType>>;
  unlockAt?: InputMaybe<Scalars['DateTime']>;
};

/** Autogenerated return type of CreateAssignment */
export type CreateAssignmentPayload = {
  __typename?: 'CreateAssignmentPayload';
  assignment?: Maybe<Assignment>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of CreateCommentBankItem */
export type CreateCommentBankItemInput = {
  comment: Scalars['String'];
  courseId: Scalars['ID'];
};

/** Autogenerated return type of CreateCommentBankItem */
export type CreateCommentBankItemPayload = {
  __typename?: 'CreateCommentBankItemPayload';
  commentBankItem?: Maybe<CommentBankItem>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of CreateConversation */
export type CreateConversationInput = {
  attachmentIds?: InputMaybe<Array<Scalars['ID']>>;
  body: Scalars['String'];
  bulkMessage?: InputMaybe<Scalars['Boolean']>;
  contextCode?: InputMaybe<Scalars['String']>;
  conversationId?: InputMaybe<Scalars['ID']>;
  forceNew?: InputMaybe<Scalars['Boolean']>;
  groupConversation?: InputMaybe<Scalars['Boolean']>;
  mediaCommentId?: InputMaybe<Scalars['ID']>;
  mediaCommentType?: InputMaybe<Scalars['String']>;
  recipients: Array<Scalars['String']>;
  subject?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Array<Scalars['String']>>;
  userNote?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of CreateConversation */
export type CreateConversationPayload = {
  __typename?: 'CreateConversationPayload';
  conversations?: Maybe<Array<ConversationParticipant>>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of CreateDiscussionEntryDraft */
export type CreateDiscussionEntryDraftInput = {
  discussionEntryId?: InputMaybe<Scalars['ID']>;
  discussionTopicId: Scalars['ID'];
  fileId?: InputMaybe<Scalars['ID']>;
  includeReplyPreview?: InputMaybe<Scalars['Boolean']>;
  message: Scalars['String'];
  parentId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of CreateDiscussionEntryDraft */
export type CreateDiscussionEntryDraftPayload = {
  __typename?: 'CreateDiscussionEntryDraftPayload';
  discussionEntryDraft?: Maybe<DiscussionEntryDraft>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of CreateDiscussionEntry */
export type CreateDiscussionEntryInput = {
  discussionTopicId: Scalars['ID'];
  fileId?: InputMaybe<Scalars['ID']>;
  includeReplyPreview?: InputMaybe<Scalars['Boolean']>;
  isAnonymousAuthor?: InputMaybe<Scalars['Boolean']>;
  message: Scalars['String'];
  parentEntryId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of CreateDiscussionEntry */
export type CreateDiscussionEntryPayload = {
  __typename?: 'CreateDiscussionEntryPayload';
  discussionEntry?: Maybe<DiscussionEntry>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of CreateGroupInSet */
export type CreateGroupInSetInput = {
  groupSetId: Scalars['ID'];
  name: Scalars['String'];
};

/** Autogenerated return type of CreateGroupInSet */
export type CreateGroupInSetPayload = {
  __typename?: 'CreateGroupInSetPayload';
  errors?: Maybe<Array<ValidationError>>;
  group?: Maybe<Group>;
};

/** Autogenerated input type of CreateInternalSetting */
export type CreateInternalSettingInput = {
  name: Scalars['String'];
  value: Scalars['String'];
};

/** Autogenerated return type of CreateInternalSetting */
export type CreateInternalSettingPayload = {
  __typename?: 'CreateInternalSettingPayload';
  errors?: Maybe<Array<ValidationError>>;
  internalSetting?: Maybe<InternalSetting>;
};

/** Autogenerated input type of CreateLearningOutcomeGroup */
export type CreateLearningOutcomeGroupInput = {
  description?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  title: Scalars['String'];
  vendorGuid?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateLearningOutcomeGroup */
export type CreateLearningOutcomeGroupPayload = {
  __typename?: 'CreateLearningOutcomeGroupPayload';
  errors?: Maybe<Array<ValidationError>>;
  learningOutcomeGroup?: Maybe<LearningOutcomeGroup>;
};

/** Autogenerated input type of CreateLearningOutcome */
export type CreateLearningOutcomeInput = {
  calculationInt?: InputMaybe<Scalars['Int']>;
  calculationMethod?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
  groupId: Scalars['ID'];
  masteryPoints?: InputMaybe<Scalars['Float']>;
  ratings?: InputMaybe<Array<ProficiencyRatingInput>>;
  title: Scalars['String'];
  vendorGuid?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateLearningOutcome */
export type CreateLearningOutcomePayload = {
  __typename?: 'CreateLearningOutcomePayload';
  errors?: Maybe<Array<ValidationError>>;
  learningOutcome?: Maybe<LearningOutcome>;
};

/** Autogenerated input type of CreateModule */
export type CreateModuleInput = {
  courseId: Scalars['ID'];
  name: Scalars['String'];
};

/** Autogenerated return type of CreateModule */
export type CreateModulePayload = {
  __typename?: 'CreateModulePayload';
  errors?: Maybe<Array<ValidationError>>;
  module?: Maybe<Module>;
};

/** Autogenerated input type of CreateOutcomeCalculationMethod */
export type CreateOutcomeCalculationMethodInput = {
  calculationInt?: InputMaybe<Scalars['Int']>;
  calculationMethod: Scalars['String'];
  contextId: Scalars['ID'];
  contextType: Scalars['String'];
};

/** Autogenerated return type of CreateOutcomeCalculationMethod */
export type CreateOutcomeCalculationMethodPayload = {
  __typename?: 'CreateOutcomeCalculationMethodPayload';
  errors?: Maybe<Array<ValidationError>>;
  outcomeCalculationMethod?: Maybe<OutcomeCalculationMethod>;
};

/** Autogenerated input type of CreateOutcomeProficiency */
export type CreateOutcomeProficiencyInput = {
  contextId: Scalars['ID'];
  contextType: Scalars['String'];
  proficiencyRatings: Array<OutcomeProficiencyRatingCreate>;
};

/** Autogenerated return type of CreateOutcomeProficiency */
export type CreateOutcomeProficiencyPayload = {
  __typename?: 'CreateOutcomeProficiencyPayload';
  errors?: Maybe<Array<ValidationError>>;
  outcomeProficiency?: Maybe<OutcomeProficiency>;
};

/** Autogenerated input type of CreateSubmissionComment */
export type CreateSubmissionCommentInput = {
  attempt?: InputMaybe<Scalars['Int']>;
  comment: Scalars['String'];
  fileIds?: InputMaybe<Array<Scalars['ID']>>;
  mediaObjectId?: InputMaybe<Scalars['ID']>;
  mediaObjectType?: InputMaybe<Scalars['String']>;
  reviewerSubmissionId?: InputMaybe<Scalars['ID']>;
  submissionId: Scalars['ID'];
};

/** Autogenerated return type of CreateSubmissionComment */
export type CreateSubmissionCommentPayload = {
  __typename?: 'CreateSubmissionCommentPayload';
  errors?: Maybe<Array<ValidationError>>;
  submissionComment?: Maybe<SubmissionComment>;
};

/** Autogenerated input type of CreateSubmissionDraft */
export type CreateSubmissionDraftInput = {
  activeSubmissionType: DraftableSubmissionType;
  attempt?: InputMaybe<Scalars['Int']>;
  body?: InputMaybe<Scalars['String']>;
  externalToolId?: InputMaybe<Scalars['ID']>;
  fileIds?: InputMaybe<Array<Scalars['ID']>>;
  ltiLaunchUrl?: InputMaybe<Scalars['String']>;
  mediaId?: InputMaybe<Scalars['ID']>;
  resourceLinkLookupUuid?: InputMaybe<Scalars['String']>;
  submissionId: Scalars['ID'];
  url?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateSubmissionDraft */
export type CreateSubmissionDraftPayload = {
  __typename?: 'CreateSubmissionDraftPayload';
  errors?: Maybe<Array<ValidationError>>;
  submissionDraft?: Maybe<SubmissionDraft>;
};

/** Autogenerated input type of CreateSubmission */
export type CreateSubmissionInput = {
  annotatableAttachmentId?: InputMaybe<Scalars['ID']>;
  assignmentId: Scalars['ID'];
  body?: InputMaybe<Scalars['String']>;
  fileIds?: InputMaybe<Array<Scalars['ID']>>;
  mediaId?: InputMaybe<Scalars['ID']>;
  resourceLinkLookupUuid?: InputMaybe<Scalars['String']>;
  studentId?: InputMaybe<Scalars['ID']>;
  submissionType: OnlineSubmissionType;
  url?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateSubmission */
export type CreateSubmissionPayload = {
  __typename?: 'CreateSubmissionPayload';
  errors?: Maybe<Array<ValidationError>>;
  submission?: Maybe<Submission>;
};

/** Autogenerated input type of DeleteAccountDomainLookup */
export type DeleteAccountDomainLookupInput = {
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteAccountDomainLookup */
export type DeleteAccountDomainLookupPayload = {
  __typename?: 'DeleteAccountDomainLookupPayload';
  accountDomainLookupId?: Maybe<Scalars['ID']>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of DeleteCommentBankItem */
export type DeleteCommentBankItemInput = {
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteCommentBankItem */
export type DeleteCommentBankItemPayload = {
  __typename?: 'DeleteCommentBankItemPayload';
  commentBankItemId: Scalars['ID'];
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of DeleteConversationMessages */
export type DeleteConversationMessagesInput = {
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteConversationMessages */
export type DeleteConversationMessagesPayload = {
  __typename?: 'DeleteConversationMessagesPayload';
  conversationMessageIds: Array<Scalars['ID']>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of DeleteConversations */
export type DeleteConversationsInput = {
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteConversations */
export type DeleteConversationsPayload = {
  __typename?: 'DeleteConversationsPayload';
  conversationIds?: Maybe<Array<Scalars['ID']>>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of DeleteDiscussionEntry */
export type DeleteDiscussionEntryInput = {
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteDiscussionEntry */
export type DeleteDiscussionEntryPayload = {
  __typename?: 'DeleteDiscussionEntryPayload';
  discussionEntry?: Maybe<DiscussionEntry>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of DeleteDiscussionTopic */
export type DeleteDiscussionTopicInput = {
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteDiscussionTopic */
export type DeleteDiscussionTopicPayload = {
  __typename?: 'DeleteDiscussionTopicPayload';
  discussionTopicId: Scalars['ID'];
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of DeleteInternalSetting */
export type DeleteInternalSettingInput = {
  internalSettingId: Scalars['ID'];
};

/** Autogenerated return type of DeleteInternalSetting */
export type DeleteInternalSettingPayload = {
  __typename?: 'DeleteInternalSettingPayload';
  errors?: Maybe<Array<ValidationError>>;
  internalSettingId: Scalars['ID'];
};

/** Autogenerated input type of DeleteOutcomeCalculationMethod */
export type DeleteOutcomeCalculationMethodInput = {
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteOutcomeCalculationMethod */
export type DeleteOutcomeCalculationMethodPayload = {
  __typename?: 'DeleteOutcomeCalculationMethodPayload';
  errors?: Maybe<Array<ValidationError>>;
  outcomeCalculationMethodId: Scalars['ID'];
};

/** Autogenerated input type of DeleteOutcomeLinks */
export type DeleteOutcomeLinksInput = {
  ids: Array<Scalars['ID']>;
};

/** Autogenerated return type of DeleteOutcomeLinks */
export type DeleteOutcomeLinksPayload = {
  __typename?: 'DeleteOutcomeLinksPayload';
  deletedOutcomeLinkIds: Array<Scalars['ID']>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of DeleteOutcomeProficiency */
export type DeleteOutcomeProficiencyInput = {
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteOutcomeProficiency */
export type DeleteOutcomeProficiencyPayload = {
  __typename?: 'DeleteOutcomeProficiencyPayload';
  errors?: Maybe<Array<ValidationError>>;
  outcomeProficiencyId: Scalars['ID'];
};

/** Autogenerated input type of DeleteSubmissionDraft */
export type DeleteSubmissionDraftInput = {
  submissionId: Scalars['ID'];
};

/** Autogenerated return type of DeleteSubmissionDraft */
export type DeleteSubmissionDraftPayload = {
  __typename?: 'DeleteSubmissionDraftPayload';
  errors?: Maybe<Array<ValidationError>>;
  submissionDraftIds?: Maybe<Array<Scalars['ID']>>;
};

export type Discussion = LegacyIdInterface & ModuleItemInterface & Node & Timestamped & {
  __typename?: 'Discussion';
  /** legacy canvas id */
  _id: Scalars['ID'];
  allowRating?: Maybe<Scalars['Boolean']>;
  anonymousAuthor?: Maybe<AnonymousUser>;
  anonymousState?: Maybe<Scalars['String']>;
  assignment?: Maybe<Assignment>;
  attachment?: Maybe<File>;
  author?: Maybe<User>;
  availableForUser: Scalars['Boolean'];
  canReplyAnonymously: Scalars['Boolean'];
  canUnpublish: Scalars['Boolean'];
  childTopics?: Maybe<Array<Discussion>>;
  contextId: Scalars['ID'];
  contextName?: Maybe<Scalars['String']>;
  contextType: Scalars['String'];
  courseSections: Array<Section>;
  createdAt?: Maybe<Scalars['DateTime']>;
  delayedPostAt?: Maybe<Scalars['DateTime']>;
  discussionEntriesConnection?: Maybe<DiscussionEntryConnection>;
  discussionEntryDraftsConnection?: Maybe<DiscussionEntryDraftConnection>;
  discussionType?: Maybe<Scalars['String']>;
  editor?: Maybe<User>;
  entriesTotalPages?: Maybe<Scalars['Int']>;
  entryCounts?: Maybe<DiscussionEntryCounts>;
  groupSet?: Maybe<GroupSet>;
  id: Scalars['ID'];
  initialPostRequiredForCurrentUser: Scalars['Boolean'];
  isAnnouncement: Scalars['Boolean'];
  isSectionSpecific?: Maybe<Scalars['Boolean']>;
  lastReplyAt?: Maybe<Scalars['DateTime']>;
  lockAt?: Maybe<Scalars['DateTime']>;
  locked: Scalars['Boolean'];
  mentionableUsersConnection?: Maybe<MessageableUserConnection>;
  message?: Maybe<Scalars['String']>;
  modules?: Maybe<Array<Module>>;
  onlyGradersCanRate?: Maybe<Scalars['Boolean']>;
  permissions?: Maybe<DiscussionPermissions>;
  podcastHasStudentPosts?: Maybe<Scalars['Boolean']>;
  position?: Maybe<Scalars['Int']>;
  postedAt?: Maybe<Scalars['DateTime']>;
  published: Scalars['Boolean'];
  requireInitialPost?: Maybe<Scalars['Boolean']>;
  rootEntriesTotalPages?: Maybe<Scalars['Int']>;
  rootTopic?: Maybe<Discussion>;
  searchEntryCount?: Maybe<Scalars['Int']>;
  sortByRating?: Maybe<Scalars['Boolean']>;
  subscribed: Scalars['Boolean'];
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userCount?: Maybe<Scalars['Int']>;
};


export type DiscussionAuthorArgs = {
  builtInOnly?: InputMaybe<Scalars['Boolean']>;
  courseId?: InputMaybe<Scalars['String']>;
  roleTypes?: InputMaybe<Array<Scalars['String']>>;
};


export type DiscussionDiscussionEntriesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<DiscussionFilterType>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  rootEntries?: InputMaybe<Scalars['Boolean']>;
  searchTerm?: InputMaybe<Scalars['String']>;
  sortOrder?: InputMaybe<DiscussionSortOrderType>;
  unreadBefore?: InputMaybe<Scalars['String']>;
  userSearchId?: InputMaybe<Scalars['String']>;
};


export type DiscussionDiscussionEntryDraftsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type DiscussionEditorArgs = {
  builtInOnly?: InputMaybe<Scalars['Boolean']>;
  courseId?: InputMaybe<Scalars['String']>;
  roleTypes?: InputMaybe<Array<Scalars['String']>>;
};


export type DiscussionEntriesTotalPagesArgs = {
  filter?: InputMaybe<DiscussionFilterType>;
  perPage: Scalars['Int'];
  rootEntries?: InputMaybe<Scalars['Boolean']>;
  searchTerm?: InputMaybe<Scalars['String']>;
  sortOrder?: InputMaybe<DiscussionSortOrderType>;
  unreadBefore?: InputMaybe<Scalars['String']>;
};


export type DiscussionMentionableUsersConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  searchTerm?: InputMaybe<Scalars['String']>;
};


export type DiscussionRootEntriesTotalPagesArgs = {
  filter?: InputMaybe<DiscussionFilterType>;
  perPage: Scalars['Int'];
  searchTerm?: InputMaybe<Scalars['String']>;
  sortOrder?: InputMaybe<DiscussionSortOrderType>;
};


export type DiscussionSearchEntryCountArgs = {
  filter?: InputMaybe<DiscussionFilterType>;
  searchTerm?: InputMaybe<Scalars['String']>;
};

export type DiscussionEntry = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'DiscussionEntry';
  /** legacy canvas id */
  _id: Scalars['ID'];
  anonymousAuthor?: Maybe<AnonymousUser>;
  attachment?: Maybe<File>;
  author?: Maybe<User>;
  createdAt?: Maybe<Scalars['DateTime']>;
  deleted?: Maybe<Scalars['Boolean']>;
  depth?: Maybe<Scalars['Int']>;
  discussionEntryVersionsConnection?: Maybe<DiscussionEntryVersionConnection>;
  discussionSubentriesConnection?: Maybe<DiscussionEntryConnection>;
  discussionTopic: Discussion;
  discussionTopicId: Scalars['ID'];
  editor?: Maybe<User>;
  entryParticipant?: Maybe<EntryParticipant>;
  id: Scalars['ID'];
  isolatedEntryId?: Maybe<Scalars['ID']>;
  lastReply?: Maybe<DiscussionEntry>;
  message?: Maybe<Scalars['String']>;
  parentId?: Maybe<Scalars['ID']>;
  permissions?: Maybe<DiscussionEntryPermissions>;
  previewMessage?: Maybe<Scalars['String']>;
  quotedEntry?: Maybe<DiscussionEntry>;
  ratingCount?: Maybe<Scalars['Int']>;
  ratingSum?: Maybe<Scalars['Int']>;
  rootEntry?: Maybe<DiscussionEntry>;
  rootEntryId?: Maybe<Scalars['ID']>;
  rootEntryParticipantCounts?: Maybe<DiscussionEntryCounts>;
  subentriesCount?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};


export type DiscussionEntryAuthorArgs = {
  builtInOnly?: InputMaybe<Scalars['Boolean']>;
  courseId?: InputMaybe<Scalars['String']>;
  roleTypes?: InputMaybe<Array<Scalars['String']>>;
};


export type DiscussionEntryDiscussionEntryVersionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type DiscussionEntryDiscussionSubentriesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  beforeRelativeEntry?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  includeRelativeEntry?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  relativeEntryId?: InputMaybe<Scalars['ID']>;
  sortOrder?: InputMaybe<DiscussionSortOrderType>;
};


export type DiscussionEntryEditorArgs = {
  builtInOnly?: InputMaybe<Scalars['Boolean']>;
  courseId?: InputMaybe<Scalars['String']>;
  roleTypes?: InputMaybe<Array<Scalars['String']>>;
};

/** The connection type for DiscussionEntry. */
export type DiscussionEntryConnection = {
  __typename?: 'DiscussionEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscussionEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DiscussionEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type DiscussionEntryCounts = {
  __typename?: 'DiscussionEntryCounts';
  deletedCount: Scalars['Int'];
  repliesCount: Scalars['Int'];
  unreadCount: Scalars['Int'];
};

export type DiscussionEntryDraft = LegacyIdInterface & Timestamped & {
  __typename?: 'DiscussionEntryDraft';
  /** legacy canvas id */
  _id: Scalars['ID'];
  attachment?: Maybe<File>;
  createdAt?: Maybe<Scalars['DateTime']>;
  discussionEntryId?: Maybe<Scalars['ID']>;
  discussionTopicId: Scalars['ID'];
  id: Scalars['ID'];
  includeReplyPreview: Scalars['Boolean'];
  message: Scalars['String'];
  parentId?: Maybe<Scalars['ID']>;
  rootEntryId?: Maybe<Scalars['ID']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

/** The connection type for DiscussionEntryDraft. */
export type DiscussionEntryDraftConnection = {
  __typename?: 'DiscussionEntryDraftConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscussionEntryDraftEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DiscussionEntryDraft>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DiscussionEntryDraftEdge = {
  __typename?: 'DiscussionEntryDraftEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DiscussionEntryDraft>;
};

/** An edge in a connection. */
export type DiscussionEntryEdge = {
  __typename?: 'DiscussionEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DiscussionEntry>;
};

export type DiscussionEntryPermissions = {
  __typename?: 'DiscussionEntryPermissions';
  attach?: Maybe<Scalars['Boolean']>;
  create?: Maybe<Scalars['Boolean']>;
  delete?: Maybe<Scalars['Boolean']>;
  rate?: Maybe<Scalars['Boolean']>;
  read?: Maybe<Scalars['Boolean']>;
  reply?: Maybe<Scalars['Boolean']>;
  update?: Maybe<Scalars['Boolean']>;
  viewRating?: Maybe<Scalars['Boolean']>;
};

export type DiscussionEntryVersion = LegacyIdInterface & Timestamped & {
  __typename?: 'DiscussionEntryVersion';
  /** legacy canvas id */
  _id: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  message: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
  version: Scalars['Int'];
};

/** The connection type for DiscussionEntryVersion. */
export type DiscussionEntryVersionConnection = {
  __typename?: 'DiscussionEntryVersionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DiscussionEntryVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DiscussionEntryVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type DiscussionEntryVersionEdge = {
  __typename?: 'DiscussionEntryVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<DiscussionEntryVersion>;
};

/** Search types that can be associated with discussions */
export enum DiscussionFilterType {
  All = 'all',
  Deleted = 'deleted',
  Drafts = 'drafts',
  Unread = 'unread'
}

export type DiscussionPermissions = {
  __typename?: 'DiscussionPermissions';
  addRubric?: Maybe<Scalars['Boolean']>;
  attach?: Maybe<Scalars['Boolean']>;
  closeForComments?: Maybe<Scalars['Boolean']>;
  copyAndSendTo?: Maybe<Scalars['Boolean']>;
  create?: Maybe<Scalars['Boolean']>;
  delete?: Maybe<Scalars['Boolean']>;
  duplicate?: Maybe<Scalars['Boolean']>;
  manageContent?: Maybe<Scalars['Boolean']>;
  manageCourseContentAdd?: Maybe<Scalars['Boolean']>;
  manageCourseContentDelete?: Maybe<Scalars['Boolean']>;
  manageCourseContentEdit?: Maybe<Scalars['Boolean']>;
  moderateForum?: Maybe<Scalars['Boolean']>;
  openForComments?: Maybe<Scalars['Boolean']>;
  peerReview?: Maybe<Scalars['Boolean']>;
  rate?: Maybe<Scalars['Boolean']>;
  read?: Maybe<Scalars['Boolean']>;
  readAsAdmin?: Maybe<Scalars['Boolean']>;
  readReplies?: Maybe<Scalars['Boolean']>;
  reply?: Maybe<Scalars['Boolean']>;
  showRubric?: Maybe<Scalars['Boolean']>;
  speedGrader?: Maybe<Scalars['Boolean']>;
  studentReporting?: Maybe<Scalars['Boolean']>;
  update?: Maybe<Scalars['Boolean']>;
};

export enum DiscussionSortOrderType {
  Asc = 'asc',
  Desc = 'desc'
}

/** Types of submissions that can have a submission draft */
export enum DraftableSubmissionType {
  BasicLtiLaunch = 'basic_lti_launch',
  MediaRecording = 'media_recording',
  OnlineTextEntry = 'online_text_entry',
  OnlineUpload = 'online_upload',
  OnlineUrl = 'online_url',
  StudentAnnotation = 'student_annotation'
}

export type Enrollment = AssetString & LegacyIdInterface & Node & Timestamped & {
  __typename?: 'Enrollment';
  /** legacy canvas id */
  _id: Scalars['ID'];
  assetString?: Maybe<Scalars['String']>;
  associatedUser?: Maybe<User>;
  canBeRemoved?: Maybe<Scalars['Boolean']>;
  course?: Maybe<Course>;
  createdAt?: Maybe<Scalars['DateTime']>;
  grades?: Maybe<Grades>;
  htmlUrl?: Maybe<Scalars['URL']>;
  id: Scalars['ID'];
  lastActivityAt?: Maybe<Scalars['DateTime']>;
  section?: Maybe<Section>;
  sisRole?: Maybe<Scalars['String']>;
  state: EnrollmentWorkflowState;
  totalActivityTime?: Maybe<Scalars['Int']>;
  type: EnrollmentType;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<User>;
};


export type EnrollmentGradesArgs = {
  gradingPeriodId?: InputMaybe<Scalars['ID']>;
};

/** The connection type for Enrollment. */
export type EnrollmentConnection = {
  __typename?: 'EnrollmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EnrollmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Enrollment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type EnrollmentEdge = {
  __typename?: 'EnrollmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Enrollment>;
};

export type EnrollmentFilterInput = {
  associatedUserIds?: InputMaybe<Array<Scalars['ID']>>;
  types?: InputMaybe<Array<EnrollmentType>>;
};

export enum EnrollmentType {
  DesignerEnrollment = 'DesignerEnrollment',
  ObserverEnrollment = 'ObserverEnrollment',
  StudentEnrollment = 'StudentEnrollment',
  StudentViewEnrollment = 'StudentViewEnrollment',
  TaEnrollment = 'TaEnrollment',
  TeacherEnrollment = 'TeacherEnrollment'
}

export enum EnrollmentWorkflowState {
  Active = 'active',
  Completed = 'completed',
  CreationPending = 'creation_pending',
  Deleted = 'deleted',
  Inactive = 'inactive',
  Invited = 'invited',
  Rejected = 'rejected'
}

export type EntryParticipant = {
  __typename?: 'EntryParticipant';
  forcedReadState?: Maybe<Scalars['Boolean']>;
  rating?: Maybe<Scalars['Boolean']>;
  read: Scalars['Boolean'];
  reportType?: Maybe<Scalars['String']>;
};

export type ExternalTool = LegacyIdInterface & ModuleItemInterface & Timestamped & {
  __typename?: 'ExternalTool';
  /** legacy canvas id */
  _id: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  modules?: Maybe<Array<Module>>;
  name?: Maybe<Scalars['String']>;
  settings?: Maybe<ExternalToolSettings>;
  state?: Maybe<ExternalToolState>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  url?: Maybe<Scalars['URL']>;
};

/** The connection type for ExternalTool. */
export type ExternalToolConnection = {
  __typename?: 'ExternalToolConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ExternalToolEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ExternalTool>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ExternalToolEdge = {
  __typename?: 'ExternalToolEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ExternalTool>;
};

export type ExternalToolFilterInput = {
  placement?: InputMaybe<ExternalToolPlacement>;
  state?: InputMaybe<ExternalToolState>;
};

/** Placements that an External Tool can have */
export enum ExternalToolPlacement {
  HomeworkSubmission = 'homework_submission'
}

export type ExternalToolPlacements = {
  __typename?: 'ExternalToolPlacements';
  canvasIconClass?: Maybe<Scalars['String']>;
  iconUrl?: Maybe<Scalars['URL']>;
  messageType?: Maybe<Scalars['String']>;
  text?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['URL']>;
};

export type ExternalToolSettings = {
  __typename?: 'ExternalToolSettings';
  homeworkSubmission?: Maybe<ExternalToolPlacements>;
  iconUrl?: Maybe<Scalars['URL']>;
  selectionHeight?: Maybe<Scalars['Int']>;
  selectionWidth?: Maybe<Scalars['Int']>;
  text?: Maybe<Scalars['String']>;
};

/** States that an External Tool can be in */
export enum ExternalToolState {
  Anonymous = 'anonymous',
  EmailOnly = 'email_only',
  NameOnly = 'name_only',
  Public = 'public'
}

export type ExternalUrl = LegacyIdInterface & ModuleItemInterface & Timestamped & {
  __typename?: 'ExternalUrl';
  /** legacy canvas id */
  _id: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  modules?: Maybe<Array<Module>>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  url?: Maybe<Scalars['String']>;
};

export type File = LegacyIdInterface & ModuleItemInterface & Node & Timestamped & {
  __typename?: 'File';
  /** legacy canvas id */
  _id: Scalars['ID'];
  contentType?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  displayName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  mimeClass?: Maybe<Scalars['String']>;
  modules?: Maybe<Array<Module>>;
  size?: Maybe<Scalars['String']>;
  submissionPreviewUrl?: Maybe<Scalars['URL']>;
  thumbnailUrl?: Maybe<Scalars['URL']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  url?: Maybe<Scalars['URL']>;
};


export type FileSubmissionPreviewUrlArgs = {
  submissionId: Scalars['ID'];
};

/** The connection type for File. */
export type FileConnection = {
  __typename?: 'FileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<FileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<File>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type FileEdge = {
  __typename?: 'FileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<File>;
};

export enum GradeState {
  Active = 'active',
  Deleted = 'deleted'
}

/** Contains grade information for a course or grading period */
export type Grades = {
  __typename?: 'Grades';
  assignmentGroup?: Maybe<AssignmentGroup>;
  currentGrade?: Maybe<Scalars['String']>;
  /**
   * The current score includes all graded assignments, excluding muted submissions.
   *
   */
  currentScore?: Maybe<Scalars['Float']>;
  enrollment?: Maybe<Enrollment>;
  finalGrade?: Maybe<Scalars['String']>;
  /**
   * The final score includes all assignments, excluding muted submissions
   * (ungraded assignments are counted as 0 points).
   *
   */
  finalScore?: Maybe<Scalars['Float']>;
  gradingPeriod?: Maybe<GradingPeriod>;
  /**
   * The override grade. Supersedes the computed final grade if set.
   *
   */
  overrideGrade?: Maybe<Scalars['String']>;
  /**
   * The override score. Supersedes the computed final score if set.
   *
   */
  overrideScore?: Maybe<Scalars['Float']>;
  state: GradeState;
  unpostedCurrentGrade?: Maybe<Scalars['String']>;
  /**
   * The current score includes all graded assignments, including muted submissions.
   *
   */
  unpostedCurrentScore?: Maybe<Scalars['Float']>;
  unpostedFinalGrade?: Maybe<Scalars['String']>;
  /**
   * The final score includes all assignments, including muted submissions
   * (ungraded assignments are counted as 0 points).
   *
   */
  unpostedFinalScore?: Maybe<Scalars['Float']>;
};

/** The connection type for Grades. */
export type GradesConnection = {
  __typename?: 'GradesConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GradesEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Grades>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GradesEdge = {
  __typename?: 'GradesEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Grades>;
};

export type GradesEnrollmentFilter = {
  /** only include users with the given enrollment ids */
  enrollmentIds?: InputMaybe<Array<Scalars['ID']>>;
};

export type GradingPeriod = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'GradingPeriod';
  /** legacy canvas id */
  _id: Scalars['ID'];
  /**
   * assignments can only be graded before the grading period closes
   *
   */
  closeDate?: Maybe<Scalars['DateTime']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  startDate?: Maybe<Scalars['DateTime']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  /**
   * used to calculate how much the assignments in this grading period
   * contribute to the overall grade
   *
   */
  weight?: Maybe<Scalars['Float']>;
};

/** The connection type for GradingPeriod. */
export type GradingPeriodConnection = {
  __typename?: 'GradingPeriodConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GradingPeriodEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GradingPeriod>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GradingPeriodEdge = {
  __typename?: 'GradingPeriodEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GradingPeriod>;
};

export enum GradingType {
  GpaScale = 'gpa_scale',
  LetterGrade = 'letter_grade',
  NotGraded = 'not_graded',
  PassFail = 'pass_fail',
  Percent = 'percent',
  Points = 'points'
}

export type Group = AssetString & LegacyIdInterface & Node & Timestamped & {
  __typename?: 'Group';
  /** legacy canvas id */
  _id: Scalars['ID'];
  assetString?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  member?: Maybe<GroupMembership>;
  membersConnection?: Maybe<GroupMembershipConnection>;
  membersCount?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  sisId?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};


export type GroupMemberArgs = {
  userId: Scalars['ID'];
};


export type GroupMembersConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Group. */
export type GroupConnection = {
  __typename?: 'GroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Group>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GroupEdge = {
  __typename?: 'GroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Group>;
};

export type GroupMembership = LegacyIdInterface & Timestamped & {
  __typename?: 'GroupMembership';
  /** legacy canvas id */
  _id: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  state: GroupMembershipState;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user?: Maybe<User>;
};

/** The connection type for GroupMembership. */
export type GroupMembershipConnection = {
  __typename?: 'GroupMembershipConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupMembershipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GroupMembership>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GroupMembershipEdge = {
  __typename?: 'GroupMembershipEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GroupMembership>;
};

export enum GroupMembershipState {
  Accepted = 'accepted',
  Deleted = 'deleted',
  Invited = 'invited',
  Rejected = 'rejected',
  Requested = 'requested'
}

export type GroupSet = LegacyIdInterface & Node & {
  __typename?: 'GroupSet';
  /** legacy canvas id */
  _id: Scalars['ID'];
  autoLeader?: Maybe<AutoLeaderPolicy>;
  currentGroup?: Maybe<Group>;
  groupsConnection?: Maybe<GroupConnection>;
  id: Scalars['ID'];
  /**
   * Sets a cap on the number of members in the group.  Only applies when
   * self-signup is enabled.
   *
   */
  memberLimit?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  selfSignup: SelfSignupPolicy;
  sisId?: Maybe<Scalars['String']>;
};


export type GroupSetGroupsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for GroupSet. */
export type GroupSetConnection = {
  __typename?: 'GroupSetConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GroupSetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<GroupSet>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type GroupSetEdge = {
  __typename?: 'GroupSetEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<GroupSet>;
};

/** Autogenerated input type of HideAssignmentGradesForSections */
export type HideAssignmentGradesForSectionsInput = {
  assignmentId: Scalars['ID'];
  sectionIds: Array<Scalars['ID']>;
};

/** Autogenerated return type of HideAssignmentGradesForSections */
export type HideAssignmentGradesForSectionsPayload = {
  __typename?: 'HideAssignmentGradesForSectionsPayload';
  assignment?: Maybe<Assignment>;
  errors?: Maybe<Array<ValidationError>>;
  progress?: Maybe<Progress>;
  sections?: Maybe<Array<Section>>;
};

/** Autogenerated input type of HideAssignmentGrades */
export type HideAssignmentGradesInput = {
  assignmentId: Scalars['ID'];
  onlyStudentIds?: InputMaybe<Array<Scalars['ID']>>;
  sectionIds?: InputMaybe<Array<Scalars['ID']>>;
  skipStudentIds?: InputMaybe<Array<Scalars['ID']>>;
};

/** Autogenerated return type of HideAssignmentGrades */
export type HideAssignmentGradesPayload = {
  __typename?: 'HideAssignmentGradesPayload';
  assignment?: Maybe<Assignment>;
  errors?: Maybe<Array<ValidationError>>;
  progress?: Maybe<Progress>;
  sections?: Maybe<Array<Section>>;
};

/** Autogenerated input type of ImportOutcomes */
export type ImportOutcomesInput = {
  groupId?: InputMaybe<Scalars['ID']>;
  outcomeId?: InputMaybe<Scalars['ID']>;
  sourceContextId?: InputMaybe<Scalars['ID']>;
  sourceContextType?: InputMaybe<Scalars['String']>;
  targetContextId?: InputMaybe<Scalars['ID']>;
  targetContextType?: InputMaybe<Scalars['String']>;
  targetGroupId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of ImportOutcomes */
export type ImportOutcomesPayload = {
  __typename?: 'ImportOutcomesPayload';
  errors?: Maybe<Array<ValidationError>>;
  progress?: Maybe<Progress>;
};

export type InternalSetting = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'InternalSetting';
  /** legacy canvas id */
  _id: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  secret: Scalars['Boolean'];
  updatedAt?: Maybe<Scalars['DateTime']>;
  value?: Maybe<Scalars['String']>;
};

export enum LatePolicyStatusType {
  Extended = 'extended',
  Late = 'late',
  Missing = 'missing',
  None = 'none'
}

export type LearningOutcome = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'LearningOutcome';
  /** legacy canvas id */
  _id: Scalars['ID'];
  alignments?: Maybe<Array<OutcomeAlignment>>;
  assessed: Scalars['Boolean'];
  calculationInt?: Maybe<Scalars['Int']>;
  calculationMethod?: Maybe<Scalars['String']>;
  canEdit: Scalars['Boolean'];
  contextId?: Maybe<Scalars['ID']>;
  contextType?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  displayName?: Maybe<Scalars['String']>;
  friendlyDescription?: Maybe<OutcomeFriendlyDescriptionType>;
  id: Scalars['ID'];
  isImported?: Maybe<Scalars['Boolean']>;
  masteryPoints?: Maybe<Scalars['Float']>;
  pointsPossible?: Maybe<Scalars['Float']>;
  ratings?: Maybe<Array<ProficiencyRating>>;
  title: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
  vendorGuid?: Maybe<Scalars['String']>;
};


export type LearningOutcomeAlignmentsArgs = {
  contextId: Scalars['ID'];
  contextType: Scalars['String'];
};


export type LearningOutcomeFriendlyDescriptionArgs = {
  contextId: Scalars['ID'];
  contextType: Scalars['String'];
};


export type LearningOutcomeIsImportedArgs = {
  targetContextId: Scalars['ID'];
  targetContextType: Scalars['String'];
};

/** Learning Outcome Group */
export type LearningOutcomeGroup = LegacyIdInterface & Node & {
  __typename?: 'LearningOutcomeGroup';
  /** legacy canvas id */
  _id: Scalars['ID'];
  canEdit: Scalars['Boolean'];
  childGroups?: Maybe<LearningOutcomeGroupConnection>;
  childGroupsCount: Scalars['Int'];
  contextId?: Maybe<Scalars['ID']>;
  contextType?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  notImportedOutcomesCount?: Maybe<Scalars['Int']>;
  outcomes: ContentTagConnection;
  outcomesCount: Scalars['Int'];
  parentOutcomeGroup?: Maybe<LearningOutcomeGroup>;
  title: Scalars['String'];
  vendorGuid?: Maybe<Scalars['String']>;
};


/** Learning Outcome Group */
export type LearningOutcomeGroupChildGroupsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Learning Outcome Group */
export type LearningOutcomeGroupNotImportedOutcomesCountArgs = {
  targetGroupId?: InputMaybe<Scalars['ID']>;
};


/** Learning Outcome Group */
export type LearningOutcomeGroupOutcomesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  searchQuery?: InputMaybe<Scalars['String']>;
};


/** Learning Outcome Group */
export type LearningOutcomeGroupOutcomesCountArgs = {
  searchQuery?: InputMaybe<Scalars['String']>;
};

/** The connection type for LearningOutcomeGroup. */
export type LearningOutcomeGroupConnection = {
  __typename?: 'LearningOutcomeGroupConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LearningOutcomeGroupEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LearningOutcomeGroup>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type LearningOutcomeGroupEdge = {
  __typename?: 'LearningOutcomeGroupEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<LearningOutcomeGroup>;
};

export type LegacyIdInterface = {
  /** legacy canvas id */
  _id: Scalars['ID'];
};

export type LockInfo = {
  __typename?: 'LockInfo';
  canView?: Maybe<Scalars['Boolean']>;
  isLocked: Scalars['Boolean'];
  lockAt?: Maybe<Scalars['DateTime']>;
  lockedObject?: Maybe<Lockable>;
  module?: Maybe<Module>;
  unlockAt?: Maybe<Scalars['DateTime']>;
};

/** Types that can be locked */
export type Lockable = Assignment | Discussion | Module | Page | Quiz;

/** Autogenerated input type of MarkSubmissionCommentsRead */
export type MarkSubmissionCommentsReadInput = {
  submissionCommentIds: Array<Scalars['ID']>;
  submissionId: Scalars['ID'];
};

/** Autogenerated return type of MarkSubmissionCommentsRead */
export type MarkSubmissionCommentsReadPayload = {
  __typename?: 'MarkSubmissionCommentsReadPayload';
  errors?: Maybe<Array<ValidationError>>;
  submissionComments?: Maybe<Array<SubmissionComment>>;
};

export type MediaObject = Node & {
  __typename?: 'MediaObject';
  /** legacy canvas id */
  _id: Scalars['ID'];
  canAddCaptions?: Maybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  mediaSources?: Maybe<Array<MediaSource>>;
  mediaTracks?: Maybe<Array<MediaTrack>>;
  mediaType?: Maybe<MediaType>;
  title?: Maybe<Scalars['String']>;
};

export type MediaSource = {
  __typename?: 'MediaSource';
  bitrate?: Maybe<Scalars['String']>;
  contentType?: Maybe<Scalars['String']>;
  fileExt?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['String']>;
  isOriginal?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['URL']>;
  width?: Maybe<Scalars['String']>;
};

export type MediaTrack = LegacyIdInterface & {
  __typename?: 'MediaTrack';
  /** legacy canvas id */
  _id: Scalars['ID'];
  content: Scalars['String'];
  kind?: Maybe<Scalars['String']>;
  locale?: Maybe<Scalars['String']>;
  mediaObject?: Maybe<MediaObject>;
  webvttContent?: Maybe<Scalars['String']>;
};

export enum MediaType {
  Audio = 'audio',
  Video = 'video'
}

export type MessagePermissions = {
  __typename?: 'MessagePermissions';
  sendMessages: Scalars['Boolean'];
  sendMessagesAll: Scalars['Boolean'];
};

export type MessageableContext = Node & {
  __typename?: 'MessageableContext';
  avatarUrl: Scalars['String'];
  id: Scalars['ID'];
  itemCount?: Maybe<Scalars['Int']>;
  name: Scalars['String'];
  permissions?: Maybe<MessagePermissions>;
  userCount?: Maybe<Scalars['Int']>;
};

/** The connection type for MessageableContext. */
export type MessageableContextConnection = {
  __typename?: 'MessageableContextConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MessageableContextEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MessageableContext>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MessageableContextEdge = {
  __typename?: 'MessageableContextEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MessageableContext>;
};

export type MessageableUser = Node & {
  __typename?: 'MessageableUser';
  /** legacy canvas id */
  _id: Scalars['ID'];
  commonCoursesConnection?: Maybe<EnrollmentConnection>;
  commonGroupsConnection?: Maybe<GroupConnection>;
  id: Scalars['ID'];
  name: Scalars['String'];
  observerEnrollmentsConnection?: Maybe<EnrollmentConnection>;
};


export type MessageableUserCommonCoursesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MessageableUserCommonGroupsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type MessageableUserObserverEnrollmentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  contextCode: Scalars['String'];
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for MessageableUser. */
export type MessageableUserConnection = {
  __typename?: 'MessageableUserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MessageableUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MessageableUser>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MessageableUserEdge = {
  __typename?: 'MessageableUserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MessageableUser>;
};

/** Settings for Moderated Grading on an Assignment */
export type ModeratedGrading = {
  __typename?: 'ModeratedGrading';
  /** Boolean indicating if the assignment is moderated. */
  enabled?: Maybe<Scalars['Boolean']>;
  /** The user of the grader responsible for choosing final grades for this assignment. */
  finalGrader?: Maybe<User>;
  /** Boolean indicating if provisional graders' comments are visible to other provisional graders. */
  graderCommentsVisibleToGraders?: Maybe<Scalars['Boolean']>;
  /** The maximum number of provisional graders who may issue grades for this assignment. */
  graderCount?: Maybe<Scalars['Int']>;
  /** Boolean indicating if provisional graders' identities are hidden from other provisional graders. */
  graderNamesVisibleToFinalGrader?: Maybe<Scalars['Boolean']>;
  /** Boolean indicating if provisional grader identities are visible to the final grader. */
  gradersAnonymousToGraders?: Maybe<Scalars['Boolean']>;
};

export type Module = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'Module';
  /** legacy canvas id */
  _id: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  moduleItems?: Maybe<Array<ModuleItem>>;
  name?: Maybe<Scalars['String']>;
  position?: Maybe<Scalars['Int']>;
  unlockAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

/** The connection type for Module. */
export type ModuleConnection = {
  __typename?: 'ModuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ModuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Module>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ModuleEdge = {
  __typename?: 'ModuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Module>;
};

export type ModuleExternalTool = LegacyIdInterface & ModuleItemInterface & Timestamped & {
  __typename?: 'ModuleExternalTool';
  /** legacy canvas id */
  _id: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  modules?: Maybe<Array<Module>>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  url?: Maybe<Scalars['String']>;
};

export type ModuleItem = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'ModuleItem';
  /** legacy canvas id */
  _id: Scalars['ID'];
  content?: Maybe<ModuleItemInterface>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  module?: Maybe<Module>;
  next?: Maybe<ModuleItem>;
  previous?: Maybe<ModuleItem>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  url?: Maybe<Scalars['URL']>;
};

/** An item that can be in context modules */
export type ModuleItemInterface = {
  modules?: Maybe<Array<Module>>;
};

/** Autogenerated input type of MoveOutcomeLinks */
export type MoveOutcomeLinksInput = {
  /**
   * The id of the destination group
   *
   */
  groupId: Scalars['ID'];
  /**
   * A list of ContentTags that will be moved
   *
   */
  outcomeLinkIds: Array<Scalars['ID']>;
};

/** Autogenerated return type of MoveOutcomeLinks */
export type MoveOutcomeLinksPayload = {
  __typename?: 'MoveOutcomeLinksPayload';
  errors?: Maybe<Array<ValidationError>>;
  /**
   * List of Outcome Links that were sucessfully moved to the group
   *
   */
  movedOutcomeLinks: Array<ContentTag>;
};

export type Mutation = {
  __typename?: 'Mutation';
  addConversationMessage?: Maybe<AddConversationMessagePayload>;
  createAccountDomainLookup?: Maybe<CreateAccountDomainLookupPayload>;
  createAssignment?: Maybe<CreateAssignmentPayload>;
  createCommentBankItem?: Maybe<CreateCommentBankItemPayload>;
  createConversation?: Maybe<CreateConversationPayload>;
  createDiscussionEntry?: Maybe<CreateDiscussionEntryPayload>;
  createDiscussionEntryDraft?: Maybe<CreateDiscussionEntryDraftPayload>;
  createGroupInSet?: Maybe<CreateGroupInSetPayload>;
  createInternalSetting?: Maybe<CreateInternalSettingPayload>;
  createLearningOutcome?: Maybe<CreateLearningOutcomePayload>;
  createLearningOutcomeGroup?: Maybe<CreateLearningOutcomeGroupPayload>;
  createModule?: Maybe<CreateModulePayload>;
  createOutcomeCalculationMethod?: Maybe<CreateOutcomeCalculationMethodPayload>;
  createOutcomeProficiency?: Maybe<CreateOutcomeProficiencyPayload>;
  /**
   * IN ACTIVE DEVELOPMENT, USE AT YOUR OWN RISK: Submit homework on an assignment.
   *
   */
  createSubmission?: Maybe<CreateSubmissionPayload>;
  createSubmissionComment?: Maybe<CreateSubmissionCommentPayload>;
  createSubmissionDraft?: Maybe<CreateSubmissionDraftPayload>;
  deleteAccountDomainLookup?: Maybe<DeleteAccountDomainLookupPayload>;
  deleteCommentBankItem?: Maybe<DeleteCommentBankItemPayload>;
  deleteConversationMessages?: Maybe<DeleteConversationMessagesPayload>;
  deleteConversations?: Maybe<DeleteConversationsPayload>;
  deleteDiscussionEntry?: Maybe<DeleteDiscussionEntryPayload>;
  deleteDiscussionTopic?: Maybe<DeleteDiscussionTopicPayload>;
  deleteInternalSetting?: Maybe<DeleteInternalSettingPayload>;
  deleteOutcomeCalculationMethod?: Maybe<DeleteOutcomeCalculationMethodPayload>;
  deleteOutcomeLinks?: Maybe<DeleteOutcomeLinksPayload>;
  deleteOutcomeProficiency?: Maybe<DeleteOutcomeProficiencyPayload>;
  deleteSubmissionDraft?: Maybe<DeleteSubmissionDraftPayload>;
  hideAssignmentGrades?: Maybe<HideAssignmentGradesPayload>;
  hideAssignmentGradesForSections?: Maybe<HideAssignmentGradesForSectionsPayload>;
  importOutcomes?: Maybe<ImportOutcomesPayload>;
  markSubmissionCommentsRead?: Maybe<MarkSubmissionCommentsReadPayload>;
  moveOutcomeLinks?: Maybe<MoveOutcomeLinksPayload>;
  postAssignmentGrades?: Maybe<PostAssignmentGradesPayload>;
  postAssignmentGradesForSections?: Maybe<PostAssignmentGradesForSectionsPayload>;
  /**
   * Sets the post policy for the assignment.
   *
   */
  setAssignmentPostPolicy?: Maybe<SetAssignmentPostPolicyPayload>;
  /**
   * Sets the post policy for the course, with an option to override and delete
   * existing assignment post policies.
   *
   */
  setCoursePostPolicy?: Maybe<SetCoursePostPolicyPayload>;
  setFriendlyDescription?: Maybe<SetFriendlyDescriptionPayload>;
  setModuleItemCompletion?: Maybe<SetModuleItemCompletionPayload>;
  /**
   * Sets the overridden final score for the associated enrollment, optionally limited to a specific
   * grading period. This will supersede the computed final score/grade if present.
   *
   */
  setOverrideScore?: Maybe<SetOverrideScorePayload>;
  subscribeToDiscussionTopic?: Maybe<SubscribeToDiscussionTopicPayload>;
  updateAccountDomainLookup?: Maybe<UpdateAccountDomainLookupPayload>;
  updateAssignment?: Maybe<UpdateAssignmentPayload>;
  updateCommentBankItem?: Maybe<UpdateCommentBankItemPayload>;
  updateConversationParticipants?: Maybe<UpdateConversationParticipantsPayload>;
  updateDiscussionEntriesReadState?: Maybe<UpdateDiscussionEntriesReadStatePayload>;
  updateDiscussionEntry?: Maybe<UpdateDiscussionEntryPayload>;
  updateDiscussionEntryParticipant?: Maybe<UpdateDiscussionEntryParticipantPayload>;
  updateDiscussionReadState?: Maybe<UpdateDiscussionReadStatePayload>;
  updateDiscussionThreadReadState?: Maybe<UpdateDiscussionThreadReadStatePayload>;
  updateDiscussionTopic?: Maybe<UpdateDiscussionTopicPayload>;
  updateInternalSetting?: Maybe<UpdateInternalSettingPayload>;
  updateIsolatedViewDeeplyNestedAlert?: Maybe<UpdateIsolatedViewDeeplyNestedAlertPayload>;
  updateLearningOutcome?: Maybe<UpdateLearningOutcomePayload>;
  updateLearningOutcomeGroup?: Maybe<UpdateLearningOutcomeGroupPayload>;
  updateNotificationPreferences?: Maybe<UpdateNotificationPreferencesPayload>;
  updateOutcomeCalculationMethod?: Maybe<UpdateOutcomeCalculationMethodPayload>;
  updateOutcomeProficiency?: Maybe<UpdateOutcomeProficiencyPayload>;
  updateSubmissionGrade?: Maybe<UpdateSubmissionsGradePayload>;
  updateSubmissionsReadState?: Maybe<UpdateSubmissionsReadStatePayload>;
  updateUserDiscussionsSplitscreenView?: Maybe<UpdateUserDiscussionsSplitscreenViewPayload>;
};


export type MutationAddConversationMessageArgs = {
  input: AddConversationMessageInput;
};


export type MutationCreateAccountDomainLookupArgs = {
  input: CreateAccountDomainLookupInput;
};


export type MutationCreateAssignmentArgs = {
  input: CreateAssignmentInput;
};


export type MutationCreateCommentBankItemArgs = {
  input: CreateCommentBankItemInput;
};


export type MutationCreateConversationArgs = {
  input: CreateConversationInput;
};


export type MutationCreateDiscussionEntryArgs = {
  input: CreateDiscussionEntryInput;
};


export type MutationCreateDiscussionEntryDraftArgs = {
  input: CreateDiscussionEntryDraftInput;
};


export type MutationCreateGroupInSetArgs = {
  input: CreateGroupInSetInput;
};


export type MutationCreateInternalSettingArgs = {
  input: CreateInternalSettingInput;
};


export type MutationCreateLearningOutcomeArgs = {
  input: CreateLearningOutcomeInput;
};


export type MutationCreateLearningOutcomeGroupArgs = {
  input: CreateLearningOutcomeGroupInput;
};


export type MutationCreateModuleArgs = {
  input: CreateModuleInput;
};


export type MutationCreateOutcomeCalculationMethodArgs = {
  input: CreateOutcomeCalculationMethodInput;
};


export type MutationCreateOutcomeProficiencyArgs = {
  input: CreateOutcomeProficiencyInput;
};


export type MutationCreateSubmissionArgs = {
  input: CreateSubmissionInput;
};


export type MutationCreateSubmissionCommentArgs = {
  input: CreateSubmissionCommentInput;
};


export type MutationCreateSubmissionDraftArgs = {
  input: CreateSubmissionDraftInput;
};


export type MutationDeleteAccountDomainLookupArgs = {
  input: DeleteAccountDomainLookupInput;
};


export type MutationDeleteCommentBankItemArgs = {
  input: DeleteCommentBankItemInput;
};


export type MutationDeleteConversationMessagesArgs = {
  input: DeleteConversationMessagesInput;
};


export type MutationDeleteConversationsArgs = {
  input: DeleteConversationsInput;
};


export type MutationDeleteDiscussionEntryArgs = {
  input: DeleteDiscussionEntryInput;
};


export type MutationDeleteDiscussionTopicArgs = {
  input: DeleteDiscussionTopicInput;
};


export type MutationDeleteInternalSettingArgs = {
  input: DeleteInternalSettingInput;
};


export type MutationDeleteOutcomeCalculationMethodArgs = {
  input: DeleteOutcomeCalculationMethodInput;
};


export type MutationDeleteOutcomeLinksArgs = {
  input: DeleteOutcomeLinksInput;
};


export type MutationDeleteOutcomeProficiencyArgs = {
  input: DeleteOutcomeProficiencyInput;
};


export type MutationDeleteSubmissionDraftArgs = {
  input: DeleteSubmissionDraftInput;
};


export type MutationHideAssignmentGradesArgs = {
  input: HideAssignmentGradesInput;
};


export type MutationHideAssignmentGradesForSectionsArgs = {
  input: HideAssignmentGradesForSectionsInput;
};


export type MutationImportOutcomesArgs = {
  input: ImportOutcomesInput;
};


export type MutationMarkSubmissionCommentsReadArgs = {
  input: MarkSubmissionCommentsReadInput;
};


export type MutationMoveOutcomeLinksArgs = {
  input: MoveOutcomeLinksInput;
};


export type MutationPostAssignmentGradesArgs = {
  input: PostAssignmentGradesInput;
};


export type MutationPostAssignmentGradesForSectionsArgs = {
  input: PostAssignmentGradesForSectionsInput;
};


export type MutationSetAssignmentPostPolicyArgs = {
  input: SetAssignmentPostPolicyInput;
};


export type MutationSetCoursePostPolicyArgs = {
  input: SetCoursePostPolicyInput;
};


export type MutationSetFriendlyDescriptionArgs = {
  input: SetFriendlyDescriptionInput;
};


export type MutationSetModuleItemCompletionArgs = {
  input: SetModuleItemCompletionInput;
};


export type MutationSetOverrideScoreArgs = {
  input: SetOverrideScoreInput;
};


export type MutationSubscribeToDiscussionTopicArgs = {
  input: SubscribeToDiscussionTopicInput;
};


export type MutationUpdateAccountDomainLookupArgs = {
  input: UpdateAccountDomainLookupInput;
};


export type MutationUpdateAssignmentArgs = {
  input: UpdateAssignmentInput;
};


export type MutationUpdateCommentBankItemArgs = {
  input: UpdateCommentBankItemInput;
};


export type MutationUpdateConversationParticipantsArgs = {
  input: UpdateConversationParticipantsInput;
};


export type MutationUpdateDiscussionEntriesReadStateArgs = {
  input: UpdateDiscussionEntriesReadStateInput;
};


export type MutationUpdateDiscussionEntryArgs = {
  input: UpdateDiscussionEntryInput;
};


export type MutationUpdateDiscussionEntryParticipantArgs = {
  input: UpdateDiscussionEntryParticipantInput;
};


export type MutationUpdateDiscussionReadStateArgs = {
  input: UpdateDiscussionReadStateInput;
};


export type MutationUpdateDiscussionThreadReadStateArgs = {
  input: UpdateDiscussionThreadReadStateInput;
};


export type MutationUpdateDiscussionTopicArgs = {
  input: UpdateDiscussionTopicInput;
};


export type MutationUpdateInternalSettingArgs = {
  input: UpdateInternalSettingInput;
};


export type MutationUpdateIsolatedViewDeeplyNestedAlertArgs = {
  input: UpdateIsolatedViewDeeplyNestedAlertInput;
};


export type MutationUpdateLearningOutcomeArgs = {
  input: UpdateLearningOutcomeInput;
};


export type MutationUpdateLearningOutcomeGroupArgs = {
  input: UpdateLearningOutcomeGroupInput;
};


export type MutationUpdateNotificationPreferencesArgs = {
  input: UpdateNotificationPreferencesInput;
};


export type MutationUpdateOutcomeCalculationMethodArgs = {
  input: UpdateOutcomeCalculationMethodInput;
};


export type MutationUpdateOutcomeProficiencyArgs = {
  input: UpdateOutcomeProficiencyInput;
};


export type MutationUpdateSubmissionGradeArgs = {
  input: UpdateSubmissionsGradeInput;
};


export type MutationUpdateSubmissionsReadStateArgs = {
  input: UpdateSubmissionsReadStateInput;
};


export type MutationUpdateUserDiscussionsSplitscreenViewArgs = {
  input: UpdateUserDiscussionsSplitscreenViewInput;
};

export type MutationLog = {
  __typename?: 'MutationLog';
  assetString: Scalars['ID'];
  mutationId: Scalars['ID'];
  mutationName: Scalars['String'];
  params?: Maybe<Scalars['JSON']>;
  /**
   * If the mutation was performed by a user masquerading as another user,
   * this field returns the "real" (logged-in) user.
   *
   */
  realUser?: Maybe<User>;
  timestamp?: Maybe<Scalars['DateTime']>;
  user?: Maybe<User>;
};

/** The connection type for MutationLog. */
export type MutationLogConnection = {
  __typename?: 'MutationLogConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MutationLogEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MutationLog>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type MutationLogEdge = {
  __typename?: 'MutationLogEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<MutationLog>;
};

/** An object with an ID. */
export type Node = {
  /** ID of the object. */
  id: Scalars['ID'];
};

export enum NodeType {
  Account = 'Account',
  Assignment = 'Assignment',
  AssignmentGroup = 'AssignmentGroup',
  Conversation = 'Conversation',
  Course = 'Course',
  Discussion = 'Discussion',
  DiscussionEntry = 'DiscussionEntry',
  Enrollment = 'Enrollment',
  File = 'File',
  GradingPeriod = 'GradingPeriod',
  Group = 'Group',
  GroupSet = 'GroupSet',
  InternalSetting = 'InternalSetting',
  LearningOutcomeGroup = 'LearningOutcomeGroup',
  MediaObject = 'MediaObject',
  Module = 'Module',
  ModuleItem = 'ModuleItem',
  OutcomeCalculationMethod = 'OutcomeCalculationMethod',
  OutcomeProficiency = 'OutcomeProficiency',
  Page = 'Page',
  PostPolicy = 'PostPolicy',
  Progress = 'Progress',
  Rubric = 'Rubric',
  Section = 'Section',
  Submission = 'Submission',
  Term = 'Term',
  User = 'User'
}

/** A descriptive tag that doesn't link the assignment to a set */
export type Noop = {
  __typename?: 'Noop';
  _id: Scalars['ID'];
};

export type Notification = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'Notification';
  /** legacy canvas id */
  _id: Scalars['ID'];
  category: Scalars['String'];
  categoryDescription: Scalars['String'];
  categoryDisplayName: Scalars['String'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
  workflowState?: Maybe<Scalars['String']>;
};

/** The categories that a notification can belong to */
export enum NotificationCategoryType {
  AccountNotification = 'Account_Notification',
  AddedToConversation = 'Added_To_Conversation',
  AllSubmissions = 'All_Submissions',
  Announcement = 'Announcement',
  AnnouncementCreatedByYou = 'Announcement_Created_By_You',
  AppointmentAvailability = 'Appointment_Availability',
  AppointmentCancelations = 'Appointment_Cancelations',
  AppointmentSignups = 'Appointment_Signups',
  Blueprint = 'Blueprint',
  Calendar = 'Calendar',
  ContentLinkError = 'Content_Link_Error',
  ConversationCreated = 'Conversation_Created',
  ConversationMessage = 'Conversation_Message',
  CourseContent = 'Course_Content',
  Discussion = 'Discussion',
  DiscussionEntry = 'DiscussionEntry',
  DiscussionMention = 'DiscussionMention',
  DueDate = 'Due_Date',
  Files = 'Files',
  Grading = 'Grading',
  GradingPolicies = 'Grading_Policies',
  Invitation = 'Invitation',
  LateGrading = 'Late_Grading',
  MembershipUpdate = 'Membership_Update',
  Other = 'Other',
  RecordingReady = 'Recording_Ready',
  ReportedReply = 'ReportedReply',
  StudentAppointmentSignups = 'Student_Appointment_Signups',
  SubmissionComment = 'Submission_Comment'
}

/** Frequency that notifications can be delivered on */
export enum NotificationFrequencyType {
  Daily = 'daily',
  Immediately = 'immediately',
  Never = 'never',
  Weekly = 'weekly'
}

export type NotificationPolicy = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'NotificationPolicy';
  /** legacy canvas id */
  _id: Scalars['ID'];
  communicationChannelId: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  frequency?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  notification?: Maybe<Notification>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type NotificationPreferences = {
  __typename?: 'NotificationPreferences';
  channels?: Maybe<Array<CommunicationChannel>>;
  readPrivacyNoticeDate?: Maybe<Scalars['String']>;
  sendObservedNamesInNotifications?: Maybe<Scalars['Boolean']>;
  sendScoresInEmails?: Maybe<Scalars['Boolean']>;
};


export type NotificationPreferencesChannelsArgs = {
  channelId?: InputMaybe<Scalars['ID']>;
};


export type NotificationPreferencesSendScoresInEmailsArgs = {
  courseId?: InputMaybe<Scalars['ID']>;
};

/** Context types that can be associated with notification preferences */
export enum NotificationPreferencesContextType {
  Account = 'Account',
  Course = 'Course'
}

/** Types that can be submitted online */
export enum OnlineSubmissionType {
  BasicLtiLaunch = 'basic_lti_launch',
  MediaRecording = 'media_recording',
  OnlineTextEntry = 'online_text_entry',
  OnlineUpload = 'online_upload',
  OnlineUrl = 'online_url',
  StudentAnnotation = 'student_annotation'
}

export enum OrderDirection {
  Ascending = 'ascending',
  Descending = 'descending'
}

export type OutcomeAlignment = LegacyIdInterface & Timestamped & {
  __typename?: 'OutcomeAlignment';
  /** legacy canvas id */
  _id: Scalars['ID'];
  assignmentContentType?: Maybe<Scalars['String']>;
  contentId: Scalars['ID'];
  contentType: Scalars['String'];
  contextId: Scalars['ID'];
  contextType: Scalars['String'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  learningOutcomeId: Scalars['ID'];
  moduleId?: Maybe<Scalars['String']>;
  moduleName?: Maybe<Scalars['String']>;
  moduleUrl?: Maybe<Scalars['String']>;
  moduleWorkflowState?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
  url: Scalars['String'];
};

/** Customized calculation method */
export type OutcomeCalculationMethod = LegacyIdInterface & Node & {
  __typename?: 'OutcomeCalculationMethod';
  /** legacy canvas id */
  _id: Scalars['ID'];
  calculationInt?: Maybe<Scalars['Int']>;
  calculationMethod: Scalars['String'];
  contextId: Scalars['ID'];
  contextType: Scalars['String'];
  id: Scalars['ID'];
  locked: Scalars['Boolean'];
};

export type OutcomeFriendlyDescriptionType = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'OutcomeFriendlyDescriptionType';
  /** legacy canvas id */
  _id: Scalars['ID'];
  contextId: Scalars['ID'];
  contextType: Scalars['String'];
  createdAt?: Maybe<Scalars['DateTime']>;
  description: Scalars['String'];
  id: Scalars['ID'];
  learningOutcomeId: Scalars['ID'];
  updatedAt?: Maybe<Scalars['DateTime']>;
  workflowState: Scalars['String'];
};

/** Customized proficiency ratings */
export type OutcomeProficiency = LegacyIdInterface & Node & {
  __typename?: 'OutcomeProficiency';
  /** legacy canvas id */
  _id: Scalars['ID'];
  contextId: Scalars['ID'];
  contextType: Scalars['String'];
  id: Scalars['ID'];
  locked: Scalars['Boolean'];
  proficiencyRatingsConnection?: Maybe<ProficiencyRatingConnection>;
};


/** Customized proficiency ratings */
export type OutcomeProficiencyProficiencyRatingsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type OutcomeProficiencyRatingCreate = {
  color: Scalars['String'];
  description: Scalars['String'];
  mastery: Scalars['Boolean'];
  points: Scalars['Float'];
};

export type Page = LegacyIdInterface & ModuleItemInterface & Node & Timestamped & {
  __typename?: 'Page';
  /** legacy canvas id */
  _id: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  modules?: Maybe<Array<Module>>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

export type PageViewAnalysis = {
  __typename?: 'PageViewAnalysis';
  /** This number (0-3) is intended to give an idea of how the student is doing relative to others in the course */
  level?: Maybe<Scalars['Int']>;
  /** The maximum number of views/participations in this course */
  max?: Maybe<Scalars['Int']>;
  /** The number of views/participations this student has */
  total?: Maybe<Scalars['Int']>;
};

/** Settings for Peer Reviews on an Assignment */
export type PeerReviews = {
  __typename?: 'PeerReviews';
  /** Boolean representing whether or not peer reviews are anonymous */
  anonymousReviews?: Maybe<Scalars['Boolean']>;
  /** Boolean indicating peer reviews are assigned automatically. If false, the teacher is expected to manually assign peer reviews. */
  automaticReviews?: Maybe<Scalars['Boolean']>;
  /** Integer representing the amount of reviews each user is assigned. */
  count?: Maybe<Scalars['Int']>;
  /** Date and Time representing when the peer reviews are due */
  dueAt?: Maybe<Scalars['DateTime']>;
  /** Boolean indicating if peer reviews are required for this assignment */
  enabled?: Maybe<Scalars['Boolean']>;
  /** Boolean representing whether or not members from within the same group on a group assignment can be assigned to peer review their own group's work */
  intraReviews?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated input type of PostAssignmentGradesForSections */
export type PostAssignmentGradesForSectionsInput = {
  assignmentId: Scalars['ID'];
  gradedOnly?: InputMaybe<Scalars['Boolean']>;
  sectionIds: Array<Scalars['ID']>;
};

/** Autogenerated return type of PostAssignmentGradesForSections */
export type PostAssignmentGradesForSectionsPayload = {
  __typename?: 'PostAssignmentGradesForSectionsPayload';
  assignment?: Maybe<Assignment>;
  errors?: Maybe<Array<ValidationError>>;
  progress?: Maybe<Progress>;
  sections?: Maybe<Array<Section>>;
};

/** Autogenerated input type of PostAssignmentGrades */
export type PostAssignmentGradesInput = {
  assignmentId: Scalars['ID'];
  gradedOnly?: InputMaybe<Scalars['Boolean']>;
  onlyStudentIds?: InputMaybe<Array<Scalars['ID']>>;
  sectionIds?: InputMaybe<Array<Scalars['ID']>>;
  skipStudentIds?: InputMaybe<Array<Scalars['ID']>>;
};

/** Autogenerated return type of PostAssignmentGrades */
export type PostAssignmentGradesPayload = {
  __typename?: 'PostAssignmentGradesPayload';
  assignment?: Maybe<Assignment>;
  errors?: Maybe<Array<ValidationError>>;
  progress?: Maybe<Progress>;
  sections?: Maybe<Array<Section>>;
};

/**
 * A PostPolicy sets the policy for whether a Submission's grades are posted
 * automatically or manually. A PostPolicy can be set at the Course and/or
 * Assignment level.
 *
 */
export type PostPolicy = LegacyIdInterface & Node & {
  __typename?: 'PostPolicy';
  /** legacy canvas id */
  _id: Scalars['ID'];
  assignment?: Maybe<Assignment>;
  course: Course;
  /** ID of the object. */
  id: Scalars['ID'];
  postManually: Scalars['Boolean'];
};

/** The connection type for PostPolicy. */
export type PostPolicyConnection = {
  __typename?: 'PostPolicyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PostPolicyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PostPolicy>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type PostPolicyEdge = {
  __typename?: 'PostPolicyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<PostPolicy>;
};

/** Customized proficiency rating */
export type ProficiencyRating = LegacyIdInterface & {
  __typename?: 'ProficiencyRating';
  /** legacy canvas id */
  _id: Scalars['ID'];
  color?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  mastery: Scalars['Boolean'];
  points?: Maybe<Scalars['Float']>;
};

/** The connection type for ProficiencyRating. */
export type ProficiencyRatingConnection = {
  __typename?: 'ProficiencyRatingConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProficiencyRatingEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ProficiencyRating>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ProficiencyRatingEdge = {
  __typename?: 'ProficiencyRatingEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<ProficiencyRating>;
};

export type ProficiencyRatingInput = {
  description: Scalars['String'];
  points: Scalars['Float'];
};

/** Returns completion status and progress information about an asynchronous job */
export type Progress = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'Progress';
  /** legacy canvas id */
  _id: Scalars['ID'];
  /** percent completed */
  completion?: Maybe<Scalars['Int']>;
  context?: Maybe<ProgressContext>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  /** details about the job */
  message?: Maybe<Scalars['String']>;
  state: ProgressState;
  /** the type of operation */
  tag: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type ProgressContext = Assignment | Course | File | GroupSet | User;

export enum ProgressState {
  Completed = 'completed',
  Failed = 'failed',
  Queued = 'queued',
  Running = 'running'
}

export type Query = {
  __typename?: 'Query';
  account?: Maybe<Account>;
  /** All courses viewable by the current user */
  allCourses?: Maybe<Array<Course>>;
  assignment?: Maybe<Assignment>;
  assignmentGroup?: Maybe<AssignmentGroup>;
  auditLogs?: Maybe<AuditLogs>;
  course?: Maybe<Course>;
  /** Retrieves a single internal setting by its ID or name */
  internalSetting?: Maybe<InternalSetting>;
  /** All internal settings */
  internalSettings?: Maybe<Array<InternalSetting>>;
  /** LearningOutcome */
  learningOutcome?: Maybe<LearningOutcome>;
  /** LearningOutcomeGroup */
  learningOutcomeGroup?: Maybe<LearningOutcomeGroup>;
  /** Fetches an object given its type and legacy ID */
  legacyNode?: Maybe<Node>;
  /** ModuleItem */
  moduleItem?: Maybe<ModuleItem>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** OutcomeCalculationMethod */
  outcomeCalculationMethod?: Maybe<OutcomeCalculationMethod>;
  /** OutcomeProficiency */
  outcomeProficiency?: Maybe<OutcomeProficiency>;
  submission?: Maybe<Submission>;
  term?: Maybe<Term>;
};


export type QueryAccountArgs = {
  id?: InputMaybe<Scalars['ID']>;
  sisId?: InputMaybe<Scalars['String']>;
};


export type QueryAssignmentArgs = {
  id?: InputMaybe<Scalars['ID']>;
  sisId?: InputMaybe<Scalars['String']>;
};


export type QueryAssignmentGroupArgs = {
  id?: InputMaybe<Scalars['ID']>;
  sisId?: InputMaybe<Scalars['String']>;
};


export type QueryCourseArgs = {
  id?: InputMaybe<Scalars['ID']>;
  sisId?: InputMaybe<Scalars['String']>;
};


export type QueryInternalSettingArgs = {
  id?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
};


export type QueryLearningOutcomeArgs = {
  id: Scalars['ID'];
};


export type QueryLearningOutcomeGroupArgs = {
  id: Scalars['ID'];
};


export type QueryLegacyNodeArgs = {
  _id: Scalars['ID'];
  type: NodeType;
};


export type QueryModuleItemArgs = {
  id: Scalars['ID'];
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
};


export type QueryOutcomeCalculationMethodArgs = {
  id: Scalars['ID'];
};


export type QueryOutcomeProficiencyArgs = {
  id: Scalars['ID'];
};


export type QuerySubmissionArgs = {
  id: Scalars['ID'];
};


export type QueryTermArgs = {
  id?: InputMaybe<Scalars['ID']>;
  sisId?: InputMaybe<Scalars['String']>;
};

export type Quiz = LegacyIdInterface & ModuleItemInterface & Node & Timestamped & {
  __typename?: 'Quiz';
  /** legacy canvas id */
  _id: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  modules?: Maybe<Array<Module>>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export enum RatingInputType {
  Liked = 'liked',
  NotLiked = 'not_liked'
}

export type Recipients = {
  __typename?: 'Recipients';
  contextsConnection?: Maybe<MessageableContextConnection>;
  sendMessagesAll?: Maybe<Scalars['Boolean']>;
  usersConnection?: Maybe<MessageableUserConnection>;
};


export type RecipientsContextsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type RecipientsUsersConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export enum ReportType {
  Inappropriate = 'inappropriate',
  Offensive = 'offensive',
  Other = 'other'
}

export type Rubric = LegacyIdInterface & Node & {
  __typename?: 'Rubric';
  /** legacy canvas id */
  _id: Scalars['ID'];
  /**
   * The different criteria that makes up this rubric
   *
   */
  criteria: Array<RubricCriterion>;
  freeFormCriterionComments: Scalars['Boolean'];
  hideScoreTotal: Scalars['Boolean'];
  id: Scalars['ID'];
  pointsPossible?: Maybe<Scalars['Float']>;
  title?: Maybe<Scalars['String']>;
};

/** An assessment for a rubric */
export type RubricAssessment = LegacyIdInterface & {
  __typename?: 'RubricAssessment';
  /** legacy canvas id */
  _id: Scalars['ID'];
  artifactAttempt: Scalars['Int'];
  /**
   * The assessments for the individual criteria in this rubric
   *
   */
  assessmentRatings: Array<RubricAssessmentRating>;
  assessmentType: AssessmentType;
  assessor?: Maybe<User>;
  rubricAssociation?: Maybe<RubricAssociation>;
  score?: Maybe<Scalars['Float']>;
  user?: Maybe<User>;
};

/** The connection type for RubricAssessment. */
export type RubricAssessmentConnection = {
  __typename?: 'RubricAssessmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<RubricAssessmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<RubricAssessment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type RubricAssessmentEdge = {
  __typename?: 'RubricAssessmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<RubricAssessment>;
};

/** An assessment for a specific criteria in a rubric */
export type RubricAssessmentRating = {
  __typename?: 'RubricAssessmentRating';
  /** legacy canvas id */
  _id?: Maybe<Scalars['ID']>;
  artifactAttempt: Scalars['Int'];
  comments?: Maybe<Scalars['String']>;
  commentsHtml?: Maybe<Scalars['String']>;
  /**
   * The rubric criteria that this assessment is for
   *
   */
  criterion?: Maybe<RubricCriterion>;
  description?: Maybe<Scalars['String']>;
  outcome?: Maybe<LearningOutcome>;
  points?: Maybe<Scalars['Float']>;
};

/** How a rubric is being used in a context */
export type RubricAssociation = LegacyIdInterface & {
  __typename?: 'RubricAssociation';
  /** legacy canvas id */
  _id: Scalars['ID'];
  hidePoints: Scalars['Boolean'];
  hideScoreTotal: Scalars['Boolean'];
  useForGrading: Scalars['Boolean'];
};

/** Individual criteria for a rubric */
export type RubricCriterion = LegacyIdInterface & {
  __typename?: 'RubricCriterion';
  /** legacy canvas id */
  _id: Scalars['ID'];
  criterionUseRange: Scalars['Boolean'];
  description?: Maybe<Scalars['String']>;
  ignoreForScoring: Scalars['Boolean'];
  longDescription?: Maybe<Scalars['String']>;
  masteryPoints?: Maybe<Scalars['Float']>;
  outcome?: Maybe<LearningOutcome>;
  points?: Maybe<Scalars['Float']>;
  /**
   * The possible ratings available for this criterion
   *
   */
  ratings?: Maybe<Array<RubricRating>>;
};

/** Possible rating for a rubric criterion */
export type RubricRating = LegacyIdInterface & {
  __typename?: 'RubricRating';
  /** legacy canvas id */
  _id: Scalars['ID'];
  description: Scalars['String'];
  longDescription?: Maybe<Scalars['String']>;
  points: Scalars['Float'];
};

export type Section = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'Section';
  /** legacy canvas id */
  _id: Scalars['ID'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  sisId?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userCount: Scalars['Int'];
};

/** The connection type for Section. */
export type SectionConnection = {
  __typename?: 'SectionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SectionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Section>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SectionEdge = {
  __typename?: 'SectionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Section>;
};

/**
 * Determines if/how a student may join a group. A student can belong to
 * only one group per group set at a time.
 *
 */
export enum SelfSignupPolicy {
  /** self signup is not allowed */
  Disabled = 'disabled',
  /** students may join any group */
  Enabled = 'enabled',
  /** students may join a group in their section */
  Restricted = 'restricted'
}

/** Autogenerated input type of SetAssignmentPostPolicy */
export type SetAssignmentPostPolicyInput = {
  assignmentId: Scalars['ID'];
  postManually: Scalars['Boolean'];
};

/** Autogenerated return type of SetAssignmentPostPolicy */
export type SetAssignmentPostPolicyPayload = {
  __typename?: 'SetAssignmentPostPolicyPayload';
  errors?: Maybe<Array<ValidationError>>;
  postPolicy?: Maybe<PostPolicy>;
};

/** Autogenerated input type of SetCoursePostPolicy */
export type SetCoursePostPolicyInput = {
  courseId: Scalars['ID'];
  postManually: Scalars['Boolean'];
};

/** Autogenerated return type of SetCoursePostPolicy */
export type SetCoursePostPolicyPayload = {
  __typename?: 'SetCoursePostPolicyPayload';
  errors?: Maybe<Array<ValidationError>>;
  postPolicy?: Maybe<PostPolicy>;
};

/** Autogenerated input type of SetFriendlyDescription */
export type SetFriendlyDescriptionInput = {
  contextId: Scalars['ID'];
  contextType: Scalars['String'];
  description: Scalars['String'];
  outcomeId: Scalars['ID'];
};

/** Autogenerated return type of SetFriendlyDescription */
export type SetFriendlyDescriptionPayload = {
  __typename?: 'SetFriendlyDescriptionPayload';
  errors?: Maybe<Array<ValidationError>>;
  outcomeFriendlyDescription?: Maybe<OutcomeFriendlyDescriptionType>;
};

/** Autogenerated input type of SetModuleItemCompletion */
export type SetModuleItemCompletionInput = {
  done: Scalars['Boolean'];
  itemId: Scalars['ID'];
  moduleId: Scalars['ID'];
};

/** Autogenerated return type of SetModuleItemCompletion */
export type SetModuleItemCompletionPayload = {
  __typename?: 'SetModuleItemCompletionPayload';
  errors?: Maybe<Array<ValidationError>>;
  moduleItem: ModuleItem;
};

/** Autogenerated input type of SetOverrideScore */
export type SetOverrideScoreInput = {
  enrollmentId: Scalars['ID'];
  gradingPeriodId?: InputMaybe<Scalars['ID']>;
  overrideScore?: InputMaybe<Scalars['Float']>;
};

/** Autogenerated return type of SetOverrideScore */
export type SetOverrideScorePayload = {
  __typename?: 'SetOverrideScorePayload';
  errors?: Maybe<Array<ValidationError>>;
  grades?: Maybe<Grades>;
};

/** basic information about a students activity in a course */
export type StudentSummaryAnalytics = {
  __typename?: 'StudentSummaryAnalytics';
  pageViews?: Maybe<PageViewAnalysis>;
  participations?: Maybe<PageViewAnalysis>;
  tardinessBreakdown?: Maybe<TardinessBreakdown>;
};

export type SubHeader = ModuleItemInterface & {
  __typename?: 'SubHeader';
  modules?: Maybe<Array<Module>>;
  title?: Maybe<Scalars['String']>;
};

export type Submission = LegacyIdInterface & Node & SubmissionInterface & Timestamped & {
  __typename?: 'Submission';
  /** legacy canvas id */
  _id: Scalars['ID'];
  assignedAssessments?: Maybe<Array<AssessmentRequest>>;
  assignment?: Maybe<Assignment>;
  attachment?: Maybe<File>;
  attachments?: Maybe<Array<File>>;
  attempt: Scalars['Int'];
  body?: Maybe<Scalars['String']>;
  commentsConnection?: Maybe<SubmissionCommentConnection>;
  createdAt?: Maybe<Scalars['DateTime']>;
  /** how many points are being deducted due to late policy */
  deductedPoints?: Maybe<Scalars['Float']>;
  /** the submission grade *before* late policy deductions were applied */
  enteredGrade?: Maybe<Scalars['String']>;
  /** the submission score *before* late policy deductions were applied */
  enteredScore?: Maybe<Scalars['Float']>;
  /** excused assignments are ignored when calculating grades */
  excused?: Maybe<Scalars['Boolean']>;
  extraAttempts?: Maybe<Scalars['Int']>;
  feedbackForCurrentAttempt: Scalars['Boolean'];
  grade?: Maybe<Scalars['String']>;
  gradeHidden: Scalars['Boolean'];
  /** was the grade given on the current submission (resubmission) */
  gradeMatchesCurrentSubmission?: Maybe<Scalars['Boolean']>;
  gradedAt?: Maybe<Scalars['DateTime']>;
  gradingStatus?: Maybe<SubmissionGradingStatus>;
  id: Scalars['ID'];
  late?: Maybe<Scalars['Boolean']>;
  latePolicyStatus?: Maybe<LatePolicyStatusType>;
  mediaObject?: Maybe<MediaObject>;
  missing?: Maybe<Scalars['Boolean']>;
  originalityData?: Maybe<Scalars['JSON']>;
  posted: Scalars['Boolean'];
  postedAt?: Maybe<Scalars['DateTime']>;
  proxySubmitter?: Maybe<Scalars['String']>;
  readState?: Maybe<Scalars['String']>;
  resourceLinkLookupUuid?: Maybe<Scalars['String']>;
  rubricAssessmentsConnection?: Maybe<RubricAssessmentConnection>;
  score?: Maybe<Scalars['Float']>;
  state: SubmissionState;
  submissionDraft?: Maybe<SubmissionDraft>;
  submissionHistoriesConnection?: Maybe<SubmissionHistoryConnection>;
  submissionStatus?: Maybe<Scalars['String']>;
  submissionType?: Maybe<SubmissionType>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  turnitinData?: Maybe<Array<TurnitinData>>;
  unreadCommentCount: Scalars['Int'];
  updatedAt?: Maybe<Scalars['DateTime']>;
  url?: Maybe<Scalars['URL']>;
  user?: Maybe<User>;
};


export type SubmissionCommentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<SubmissionCommentFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortOrder?: InputMaybe<SubmissionCommentsSortOrderType>;
};


export type SubmissionRubricAssessmentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<SubmissionRubricAssessmentFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type SubmissionSubmissionHistoriesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<SubmissionHistoryFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type SubmissionComment = LegacyIdInterface & Timestamped & {
  __typename?: 'SubmissionComment';
  /** legacy canvas id */
  _id: Scalars['ID'];
  assignment?: Maybe<Assignment>;
  attachments?: Maybe<Array<File>>;
  attempt: Scalars['Int'];
  author?: Maybe<User>;
  comment?: Maybe<Scalars['String']>;
  course?: Maybe<Course>;
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  mediaObject?: Maybe<MediaObject>;
  read: Scalars['Boolean'];
  submissionId: Scalars['ID'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

/** The connection type for SubmissionComment. */
export type SubmissionCommentConnection = {
  __typename?: 'SubmissionCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SubmissionCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SubmissionComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SubmissionCommentEdge = {
  __typename?: 'SubmissionCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SubmissionComment>;
};

export type SubmissionCommentFilterInput = {
  /**
   * If all of the comments, regardless of the submission attempt, should be returned.
   * If this is true, the for_attempt argument will be ignored.
   *
   */
  allComments?: InputMaybe<Scalars['Boolean']>;
  /**
   * What submission attempt the comments should be returned for. If not specified,
   * it will return the comments for the current submisssion or submission history.
   *
   */
  forAttempt?: InputMaybe<Scalars['Int']>;
};

export enum SubmissionCommentsSortOrderType {
  Asc = 'asc',
  Desc = 'desc'
}

/** The connection type for Submission. */
export type SubmissionConnection = {
  __typename?: 'SubmissionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SubmissionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Submission>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

export type SubmissionDraft = LegacyIdInterface & {
  __typename?: 'SubmissionDraft';
  /** legacy canvas id */
  _id: Scalars['ID'];
  activeSubmissionType?: Maybe<DraftableSubmissionType>;
  attachments?: Maybe<Array<File>>;
  body?: Maybe<Scalars['String']>;
  externalTool?: Maybe<ExternalTool>;
  ltiLaunchUrl?: Maybe<Scalars['URL']>;
  mediaObject?: Maybe<MediaObject>;
  meetsAssignmentCriteria: Scalars['Boolean'];
  meetsBasicLtiLaunchCriteria: Scalars['Boolean'];
  meetsMediaRecordingCriteria: Scalars['Boolean'];
  meetsStudentAnnotationCriteria: Scalars['Boolean'];
  meetsTextEntryCriteria: Scalars['Boolean'];
  meetsUploadCriteria: Scalars['Boolean'];
  meetsUrlCriteria: Scalars['Boolean'];
  resourceLinkLookupUuid?: Maybe<Scalars['String']>;
  submissionAttempt: Scalars['Int'];
  url?: Maybe<Scalars['URL']>;
};


export type SubmissionDraftBodyArgs = {
  rewriteUrls?: InputMaybe<Scalars['Boolean']>;
};

/** An edge in a connection. */
export type SubmissionEdge = {
  __typename?: 'SubmissionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Submission>;
};

export type SubmissionFilterInput = {
  gradedSince?: InputMaybe<Scalars['DateTime']>;
  sectionIds?: InputMaybe<Array<Scalars['ID']>>;
  states?: InputMaybe<Array<SubmissionState>>;
  submittedSince?: InputMaybe<Scalars['DateTime']>;
  updatedSince?: InputMaybe<Scalars['DateTime']>;
};

export enum SubmissionGradingStatus {
  Excused = 'excused',
  Graded = 'graded',
  NeedsGrading = 'needs_grading',
  NeedsReview = 'needs_review'
}

export type SubmissionHistory = SubmissionInterface & Timestamped & {
  __typename?: 'SubmissionHistory';
  assignedAssessments?: Maybe<Array<AssessmentRequest>>;
  assignment?: Maybe<Assignment>;
  attachment?: Maybe<File>;
  attachments?: Maybe<Array<File>>;
  attempt: Scalars['Int'];
  body?: Maybe<Scalars['String']>;
  commentsConnection?: Maybe<SubmissionCommentConnection>;
  createdAt?: Maybe<Scalars['DateTime']>;
  /** how many points are being deducted due to late policy */
  deductedPoints?: Maybe<Scalars['Float']>;
  /** the submission grade *before* late policy deductions were applied */
  enteredGrade?: Maybe<Scalars['String']>;
  /** the submission score *before* late policy deductions were applied */
  enteredScore?: Maybe<Scalars['Float']>;
  /** excused assignments are ignored when calculating grades */
  excused?: Maybe<Scalars['Boolean']>;
  extraAttempts?: Maybe<Scalars['Int']>;
  feedbackForCurrentAttempt: Scalars['Boolean'];
  grade?: Maybe<Scalars['String']>;
  gradeHidden: Scalars['Boolean'];
  /** was the grade given on the current submission (resubmission) */
  gradeMatchesCurrentSubmission?: Maybe<Scalars['Boolean']>;
  gradedAt?: Maybe<Scalars['DateTime']>;
  gradingStatus?: Maybe<SubmissionGradingStatus>;
  late?: Maybe<Scalars['Boolean']>;
  latePolicyStatus?: Maybe<LatePolicyStatusType>;
  mediaObject?: Maybe<MediaObject>;
  missing?: Maybe<Scalars['Boolean']>;
  originalityData?: Maybe<Scalars['JSON']>;
  posted: Scalars['Boolean'];
  postedAt?: Maybe<Scalars['DateTime']>;
  proxySubmitter?: Maybe<Scalars['String']>;
  resourceLinkLookupUuid?: Maybe<Scalars['String']>;
  /**
   * The canvas legacy id of the root submission this history belongs to
   *
   */
  rootId: Scalars['ID'];
  rubricAssessmentsConnection?: Maybe<RubricAssessmentConnection>;
  score?: Maybe<Scalars['Float']>;
  state: SubmissionState;
  submissionDraft?: Maybe<SubmissionDraft>;
  submissionStatus?: Maybe<Scalars['String']>;
  submissionType?: Maybe<SubmissionType>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  turnitinData?: Maybe<Array<TurnitinData>>;
  unreadCommentCount: Scalars['Int'];
  updatedAt?: Maybe<Scalars['DateTime']>;
  url?: Maybe<Scalars['URL']>;
  user?: Maybe<User>;
};


export type SubmissionHistoryCommentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<SubmissionCommentFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortOrder?: InputMaybe<SubmissionCommentsSortOrderType>;
};


export type SubmissionHistoryRubricAssessmentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<SubmissionRubricAssessmentFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for SubmissionHistory. */
export type SubmissionHistoryConnection = {
  __typename?: 'SubmissionHistoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SubmissionHistoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<SubmissionHistory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type SubmissionHistoryEdge = {
  __typename?: 'SubmissionHistoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<SubmissionHistory>;
};

export type SubmissionHistoryFilterInput = {
  /**
   * If the most current submission should be included in the submission
   * history results. Defaults to true.
   *
   */
  includeCurrentSubmission?: InputMaybe<Scalars['Boolean']>;
  states?: InputMaybe<Array<SubmissionState>>;
};

/** Types for submission or submission history */
export type SubmissionInterface = {
  assignedAssessments?: Maybe<Array<AssessmentRequest>>;
  assignment?: Maybe<Assignment>;
  attachment?: Maybe<File>;
  attachments?: Maybe<Array<File>>;
  attempt: Scalars['Int'];
  body?: Maybe<Scalars['String']>;
  commentsConnection?: Maybe<SubmissionCommentConnection>;
  /** how many points are being deducted due to late policy */
  deductedPoints?: Maybe<Scalars['Float']>;
  /** the submission grade *before* late policy deductions were applied */
  enteredGrade?: Maybe<Scalars['String']>;
  /** the submission score *before* late policy deductions were applied */
  enteredScore?: Maybe<Scalars['Float']>;
  /** excused assignments are ignored when calculating grades */
  excused?: Maybe<Scalars['Boolean']>;
  extraAttempts?: Maybe<Scalars['Int']>;
  feedbackForCurrentAttempt: Scalars['Boolean'];
  grade?: Maybe<Scalars['String']>;
  gradeHidden: Scalars['Boolean'];
  /** was the grade given on the current submission (resubmission) */
  gradeMatchesCurrentSubmission?: Maybe<Scalars['Boolean']>;
  gradedAt?: Maybe<Scalars['DateTime']>;
  gradingStatus?: Maybe<SubmissionGradingStatus>;
  late?: Maybe<Scalars['Boolean']>;
  latePolicyStatus?: Maybe<LatePolicyStatusType>;
  mediaObject?: Maybe<MediaObject>;
  missing?: Maybe<Scalars['Boolean']>;
  originalityData?: Maybe<Scalars['JSON']>;
  posted: Scalars['Boolean'];
  postedAt?: Maybe<Scalars['DateTime']>;
  proxySubmitter?: Maybe<Scalars['String']>;
  resourceLinkLookupUuid?: Maybe<Scalars['String']>;
  rubricAssessmentsConnection?: Maybe<RubricAssessmentConnection>;
  score?: Maybe<Scalars['Float']>;
  state: SubmissionState;
  submissionDraft?: Maybe<SubmissionDraft>;
  submissionStatus?: Maybe<Scalars['String']>;
  submissionType?: Maybe<SubmissionType>;
  submittedAt?: Maybe<Scalars['DateTime']>;
  turnitinData?: Maybe<Array<TurnitinData>>;
  unreadCommentCount: Scalars['Int'];
  url?: Maybe<Scalars['URL']>;
  user?: Maybe<User>;
};


/** Types for submission or submission history */
export type SubmissionInterfaceCommentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<SubmissionCommentFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  sortOrder?: InputMaybe<SubmissionCommentsSortOrderType>;
};


/** Types for submission or submission history */
export type SubmissionInterfaceRubricAssessmentsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<SubmissionRubricAssessmentFilterInput>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

export type SubmissionOrderCriteria = {
  direction?: InputMaybe<OrderDirection>;
  field: SubmissionOrderField;
};

export enum SubmissionOrderField {
  Id = '_id',
  GradedAt = 'gradedAt'
}

export type SubmissionRubricAssessmentFilterInput = {
  /**
   * What submission attempt the rubric assessment should be returned for. If not
   * specified, it will return the rubric assessment for the current submisssion
   * or submission history.
   *
   */
  forAttempt?: InputMaybe<Scalars['Int']>;
};

export type SubmissionSearchFilterInput = {
  enrollmentTypes?: InputMaybe<Array<EnrollmentType>>;
  /** Limit results by grading status */
  gradingStatus?: InputMaybe<SubmissionGradingStatus>;
  /** Limit results to submissions that are late */
  late?: InputMaybe<Scalars['Boolean']>;
  /** Limit results to submissions that scored below the specified value */
  scoredLessThan?: InputMaybe<Scalars['Float']>;
  /** Limit results to submissions that scored above the specified value */
  scoredMoreThan?: InputMaybe<Scalars['Float']>;
  sectionIds?: InputMaybe<Array<Scalars['ID']>>;
  states?: InputMaybe<Array<SubmissionState>>;
  /**
   * The partial name or full ID of the users to match and return in the
   * results list. Must be at least 3 characters.
   * Queries by administrative users will search on SIS ID, login ID, name, or email
   * address; non-administrative queries will only be compared against name.
   *
   */
  userSearch?: InputMaybe<Scalars['String']>;
};

/** Specify a sort for the results */
export type SubmissionSearchOrder = {
  direction?: InputMaybe<OrderDirection>;
  field: SubmissionSearchOrderField;
};

/** The user or submission field to sort by */
export enum SubmissionSearchOrderField {
  Score = 'score',
  SubmittedAt = 'submitted_at',
  Username = 'username'
}

export enum SubmissionState {
  Deleted = 'deleted',
  Graded = 'graded',
  PendingReview = 'pending_review',
  Submitted = 'submitted',
  Ungraded = 'ungraded',
  Unsubmitted = 'unsubmitted'
}

/** Types of submissions an assignment accepts */
export enum SubmissionType {
  Attendance = 'attendance',
  BasicLtiLaunch = 'basic_lti_launch',
  DiscussionTopic = 'discussion_topic',
  ExternalTool = 'external_tool',
  MediaRecording = 'media_recording',
  None = 'none',
  NotGraded = 'not_graded',
  OnPaper = 'on_paper',
  OnlineQuiz = 'online_quiz',
  OnlineTextEntry = 'online_text_entry',
  OnlineUpload = 'online_upload',
  OnlineUrl = 'online_url',
  StudentAnnotation = 'student_annotation',
  WikiPage = 'wiki_page'
}

/** Autogenerated input type of SubscribeToDiscussionTopic */
export type SubscribeToDiscussionTopicInput = {
  discussionTopicId: Scalars['ID'];
  subscribed: Scalars['Boolean'];
};

/** Autogenerated return type of SubscribeToDiscussionTopic */
export type SubscribeToDiscussionTopicPayload = {
  __typename?: 'SubscribeToDiscussionTopicPayload';
  discussionTopic: Discussion;
  errors?: Maybe<Array<ValidationError>>;
};

/** statistics based on timeliness of student submissions */
export type TardinessBreakdown = {
  __typename?: 'TardinessBreakdown';
  late?: Maybe<Scalars['Float']>;
  missing?: Maybe<Scalars['Float']>;
  onTime?: Maybe<Scalars['Float']>;
  total?: Maybe<Scalars['Int']>;
};

export type Term = LegacyIdInterface & Node & {
  __typename?: 'Term';
  /** legacy canvas id */
  _id: Scalars['ID'];
  /** courses for this term */
  coursesConnection?: Maybe<CourseConnection>;
  endAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  sisId?: Maybe<Scalars['String']>;
  sisTermId?: Maybe<Scalars['ID']>;
  startAt?: Maybe<Scalars['DateTime']>;
};


export type TermCoursesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Contains timestamp metadata */
export type Timestamped = {
  createdAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type TurnitinContext = File | Submission;

export type TurnitinData = {
  __typename?: 'TurnitinData';
  reportUrl?: Maybe<Scalars['String']>;
  score?: Maybe<Scalars['Float']>;
  state?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  target: TurnitinContext;
};

/** Autogenerated input type of UpdateAccountDomainLookup */
export type UpdateAccountDomainLookupInput = {
  accountDomainId?: InputMaybe<Scalars['ID']>;
  accountDomainLookupId: Scalars['ID'];
  authenticationProvider?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateAccountDomainLookup */
export type UpdateAccountDomainLookupPayload = {
  __typename?: 'UpdateAccountDomainLookupPayload';
  accountDomainLookup?: Maybe<AccountDomainLookup>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of UpdateAssignment */
export type UpdateAssignmentInput = {
  allowedAttempts?: InputMaybe<Scalars['Int']>;
  allowedExtensions?: InputMaybe<Array<Scalars['String']>>;
  /** requires anonymous_marking course feature to be set to true */
  anonymousGrading?: InputMaybe<Scalars['Boolean']>;
  anonymousInstructorAnnotations?: InputMaybe<Scalars['Boolean']>;
  assignmentGroupId?: InputMaybe<Scalars['ID']>;
  assignmentOverrides?: InputMaybe<Array<AssignmentOverrideCreateOrUpdate>>;
  description?: InputMaybe<Scalars['String']>;
  dueAt?: InputMaybe<Scalars['DateTime']>;
  gradeGroupStudentsIndividually?: InputMaybe<Scalars['Boolean']>;
  gradingType?: InputMaybe<GradingType>;
  groupCategoryId?: InputMaybe<Scalars['ID']>;
  groupSetId?: InputMaybe<Scalars['ID']>;
  id: Scalars['ID'];
  lockAt?: InputMaybe<Scalars['DateTime']>;
  moderatedGrading?: InputMaybe<AssignmentModeratedGradingUpdate>;
  moduleIds?: InputMaybe<Array<Scalars['ID']>>;
  name?: InputMaybe<Scalars['String']>;
  omitFromFinalGrade?: InputMaybe<Scalars['Boolean']>;
  onlyVisibleToOverrides?: InputMaybe<Scalars['Boolean']>;
  peerReviews?: InputMaybe<AssignmentPeerReviewsUpdate>;
  pointsPossible?: InputMaybe<Scalars['Float']>;
  position?: InputMaybe<Scalars['Int']>;
  postToSis?: InputMaybe<Scalars['Boolean']>;
  state?: InputMaybe<AssignmentState>;
  submissionTypes?: InputMaybe<Array<SubmissionType>>;
  unlockAt?: InputMaybe<Scalars['DateTime']>;
};

/** Autogenerated return type of UpdateAssignment */
export type UpdateAssignmentPayload = {
  __typename?: 'UpdateAssignmentPayload';
  assignment?: Maybe<Assignment>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of UpdateCommentBankItem */
export type UpdateCommentBankItemInput = {
  comment: Scalars['String'];
  id: Scalars['ID'];
};

/** Autogenerated return type of UpdateCommentBankItem */
export type UpdateCommentBankItemPayload = {
  __typename?: 'UpdateCommentBankItemPayload';
  commentBankItem?: Maybe<CommentBankItem>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of UpdateConversationParticipants */
export type UpdateConversationParticipantsInput = {
  conversationIds: Array<Scalars['ID']>;
  starred?: InputMaybe<Scalars['Boolean']>;
  subscribed?: InputMaybe<Scalars['Boolean']>;
  workflowState?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateConversationParticipants */
export type UpdateConversationParticipantsPayload = {
  __typename?: 'UpdateConversationParticipantsPayload';
  conversationParticipants?: Maybe<Array<ConversationParticipant>>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of UpdateDiscussionEntriesReadState */
export type UpdateDiscussionEntriesReadStateInput = {
  discussionEntryIds: Array<Scalars['ID']>;
  read: Scalars['Boolean'];
};

/** Autogenerated return type of UpdateDiscussionEntriesReadState */
export type UpdateDiscussionEntriesReadStatePayload = {
  __typename?: 'UpdateDiscussionEntriesReadStatePayload';
  discussionEntries?: Maybe<Array<DiscussionEntry>>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of UpdateDiscussionEntry */
export type UpdateDiscussionEntryInput = {
  discussionEntryId: Scalars['ID'];
  fileId?: InputMaybe<Scalars['ID']>;
  includeReplyPreview?: InputMaybe<Scalars['Boolean']>;
  message?: InputMaybe<Scalars['String']>;
  removeAttachment?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated input type of UpdateDiscussionEntryParticipant */
export type UpdateDiscussionEntryParticipantInput = {
  discussionEntryId: Scalars['ID'];
  forcedReadState?: InputMaybe<Scalars['Boolean']>;
  rating?: InputMaybe<RatingInputType>;
  read?: InputMaybe<Scalars['Boolean']>;
  reportType?: InputMaybe<ReportType>;
};

/** Autogenerated return type of UpdateDiscussionEntryParticipant */
export type UpdateDiscussionEntryParticipantPayload = {
  __typename?: 'UpdateDiscussionEntryParticipantPayload';
  discussionEntry: DiscussionEntry;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated return type of UpdateDiscussionEntry */
export type UpdateDiscussionEntryPayload = {
  __typename?: 'UpdateDiscussionEntryPayload';
  discussionEntry?: Maybe<DiscussionEntry>;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of UpdateDiscussionReadState */
export type UpdateDiscussionReadStateInput = {
  discussionTopicId: Scalars['ID'];
  read: Scalars['Boolean'];
};

/** Autogenerated return type of UpdateDiscussionReadState */
export type UpdateDiscussionReadStatePayload = {
  __typename?: 'UpdateDiscussionReadStatePayload';
  discussionTopic: Discussion;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of UpdateDiscussionThreadReadState */
export type UpdateDiscussionThreadReadStateInput = {
  discussionEntryId: Scalars['ID'];
  read: Scalars['Boolean'];
};

/** Autogenerated return type of UpdateDiscussionThreadReadState */
export type UpdateDiscussionThreadReadStatePayload = {
  __typename?: 'UpdateDiscussionThreadReadStatePayload';
  discussionEntry: DiscussionEntry;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of UpdateDiscussionTopic */
export type UpdateDiscussionTopicInput = {
  discussionTopicId: Scalars['ID'];
  locked?: InputMaybe<Scalars['Boolean']>;
  published?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of UpdateDiscussionTopic */
export type UpdateDiscussionTopicPayload = {
  __typename?: 'UpdateDiscussionTopicPayload';
  discussionTopic: Discussion;
  errors?: Maybe<Array<ValidationError>>;
};

/** Autogenerated input type of UpdateInternalSetting */
export type UpdateInternalSettingInput = {
  internalSettingId: Scalars['ID'];
  value: Scalars['String'];
};

/** Autogenerated return type of UpdateInternalSetting */
export type UpdateInternalSettingPayload = {
  __typename?: 'UpdateInternalSettingPayload';
  errors?: Maybe<Array<ValidationError>>;
  internalSetting: InternalSetting;
};

/** Autogenerated input type of UpdateIsolatedViewDeeplyNestedAlert */
export type UpdateIsolatedViewDeeplyNestedAlertInput = {
  isolatedViewDeeplyNestedAlert: Scalars['Boolean'];
};

/** Autogenerated return type of UpdateIsolatedViewDeeplyNestedAlert */
export type UpdateIsolatedViewDeeplyNestedAlertPayload = {
  __typename?: 'UpdateIsolatedViewDeeplyNestedAlertPayload';
  errors?: Maybe<Array<ValidationError>>;
  user: User;
};

/** Autogenerated input type of UpdateLearningOutcomeGroup */
export type UpdateLearningOutcomeGroupInput = {
  description?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  parentOutcomeGroupId?: InputMaybe<Scalars['ID']>;
  title?: InputMaybe<Scalars['String']>;
  vendorGuid?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateLearningOutcomeGroup */
export type UpdateLearningOutcomeGroupPayload = {
  __typename?: 'UpdateLearningOutcomeGroupPayload';
  errors?: Maybe<Array<ValidationError>>;
  learningOutcomeGroup?: Maybe<LearningOutcomeGroup>;
};

/** Autogenerated input type of UpdateLearningOutcome */
export type UpdateLearningOutcomeInput = {
  calculationInt?: InputMaybe<Scalars['Int']>;
  calculationMethod?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  displayName?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  masteryPoints?: InputMaybe<Scalars['Float']>;
  ratings?: InputMaybe<Array<ProficiencyRatingInput>>;
  title: Scalars['String'];
  vendorGuid?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateLearningOutcome */
export type UpdateLearningOutcomePayload = {
  __typename?: 'UpdateLearningOutcomePayload';
  errors?: Maybe<Array<ValidationError>>;
  learningOutcome?: Maybe<LearningOutcome>;
};

/** Autogenerated input type of UpdateNotificationPreferences */
export type UpdateNotificationPreferencesInput = {
  accountId?: InputMaybe<Scalars['ID']>;
  communicationChannelId?: InputMaybe<Scalars['ID']>;
  contextType: NotificationPreferencesContextType;
  courseId?: InputMaybe<Scalars['ID']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  frequency?: InputMaybe<NotificationFrequencyType>;
  hasReadPrivacyNotice?: InputMaybe<Scalars['Boolean']>;
  isPolicyOverride?: InputMaybe<Scalars['Boolean']>;
  notificationCategory?: InputMaybe<NotificationCategoryType>;
  sendObservedNamesInNotifications?: InputMaybe<Scalars['Boolean']>;
  sendScoresInEmails?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of UpdateNotificationPreferences */
export type UpdateNotificationPreferencesPayload = {
  __typename?: 'UpdateNotificationPreferencesPayload';
  errors?: Maybe<Array<ValidationError>>;
  user?: Maybe<User>;
};

/** Autogenerated input type of UpdateOutcomeCalculationMethod */
export type UpdateOutcomeCalculationMethodInput = {
  calculationInt?: InputMaybe<Scalars['Int']>;
  calculationMethod?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of UpdateOutcomeCalculationMethod */
export type UpdateOutcomeCalculationMethodPayload = {
  __typename?: 'UpdateOutcomeCalculationMethodPayload';
  errors?: Maybe<Array<ValidationError>>;
  outcomeCalculationMethod?: Maybe<OutcomeCalculationMethod>;
};

/** Autogenerated input type of UpdateOutcomeProficiency */
export type UpdateOutcomeProficiencyInput = {
  id: Scalars['ID'];
  proficiencyRatings?: InputMaybe<Array<OutcomeProficiencyRatingCreate>>;
};

/** Autogenerated return type of UpdateOutcomeProficiency */
export type UpdateOutcomeProficiencyPayload = {
  __typename?: 'UpdateOutcomeProficiencyPayload';
  errors?: Maybe<Array<ValidationError>>;
  outcomeProficiency?: Maybe<OutcomeProficiency>;
};

/** Autogenerated input type of UpdateSubmissionsGrade */
export type UpdateSubmissionsGradeInput = {
  score: Scalars['Int'];
  submissionId: Scalars['ID'];
};

/** Autogenerated return type of UpdateSubmissionsGrade */
export type UpdateSubmissionsGradePayload = {
  __typename?: 'UpdateSubmissionsGradePayload';
  errors?: Maybe<Array<ValidationError>>;
  submission?: Maybe<Submission>;
};

/** Autogenerated input type of UpdateSubmissionsReadState */
export type UpdateSubmissionsReadStateInput = {
  read: Scalars['Boolean'];
  submissionIds: Array<Scalars['ID']>;
};

/** Autogenerated return type of UpdateSubmissionsReadState */
export type UpdateSubmissionsReadStatePayload = {
  __typename?: 'UpdateSubmissionsReadStatePayload';
  errors?: Maybe<Array<ValidationError>>;
  submissions?: Maybe<Array<Submission>>;
};

/** Autogenerated input type of UpdateUserDiscussionsSplitscreenView */
export type UpdateUserDiscussionsSplitscreenViewInput = {
  discussionsSplitscreenView: Scalars['Boolean'];
};

/** Autogenerated return type of UpdateUserDiscussionsSplitscreenView */
export type UpdateUserDiscussionsSplitscreenViewPayload = {
  __typename?: 'UpdateUserDiscussionsSplitscreenViewPayload';
  errors?: Maybe<Array<ValidationError>>;
  user: User;
};

export type User = LegacyIdInterface & Node & Timestamped & {
  __typename?: 'User';
  /** legacy canvas id */
  _id: Scalars['ID'];
  avatarUrl?: Maybe<Scalars['URL']>;
  commentBankItemsConnection?: Maybe<CommentBankItemConnection>;
  conversationsConnection?: Maybe<ConversationParticipantConnection>;
  courseRoles?: Maybe<Array<Scalars['String']>>;
  createdAt?: Maybe<Scalars['DateTime']>;
  discussionsSplitscreenView: Scalars['Boolean'];
  email?: Maybe<Scalars['String']>;
  enrollments: Array<Enrollment>;
  favoriteCoursesConnection?: Maybe<CourseConnection>;
  favoriteGroupsConnection?: Maybe<GroupConnection>;
  /**
   * **NOTE**: this only returns groups for the currently logged-in user.
   *
   */
  groups?: Maybe<Array<Group>>;
  id: Scalars['ID'];
  integrationId?: Maybe<Scalars['String']>;
  loginId?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  notificationPreferences?: Maybe<NotificationPreferences>;
  notificationPreferencesEnabled: Scalars['Boolean'];
  pronouns?: Maybe<Scalars['String']>;
  recipients?: Maybe<Recipients>;
  recipientsObservers?: Maybe<MessageableUserConnection>;
  /** A short name the user has selected, for use in conversations or other less formal places through the site. */
  shortName?: Maybe<Scalars['String']>;
  sisId?: Maybe<Scalars['String']>;
  /** The name of the user that is should be used for sorting groups of users, such as in the gradebook. */
  sortableName?: Maybe<Scalars['String']>;
  summaryAnalytics?: Maybe<StudentSummaryAnalytics>;
  totalRecipients: Scalars['Int'];
  updatedAt?: Maybe<Scalars['DateTime']>;
  /** All submissions with comments that the current_user is able to view */
  viewableSubmissionsConnection?: Maybe<SubmissionConnection>;
};


export type UserCommentBankItemsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  limit?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
};


export type UserConversationsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<Array<Scalars['String']>>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  scope?: InputMaybe<Scalars['String']>;
};


export type UserCourseRolesArgs = {
  builtInOnly?: InputMaybe<Scalars['Boolean']>;
  courseId?: InputMaybe<Scalars['String']>;
  roleTypes?: InputMaybe<Array<Scalars['String']>>;
};


export type UserEnrollmentsArgs = {
  courseId?: InputMaybe<Scalars['ID']>;
  currentOnly?: InputMaybe<Scalars['Boolean']>;
  excludeConcluded?: InputMaybe<Scalars['Boolean']>;
  orderBy?: InputMaybe<Array<Scalars['String']>>;
};


export type UserFavoriteCoursesConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserFavoriteGroupsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type UserNotificationPreferencesEnabledArgs = {
  accountId?: InputMaybe<Scalars['ID']>;
  contextType: NotificationPreferencesContextType;
  courseId?: InputMaybe<Scalars['ID']>;
};


export type UserRecipientsArgs = {
  context?: InputMaybe<Scalars['String']>;
  search?: InputMaybe<Scalars['String']>;
};


export type UserRecipientsObserversArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  contextCode: Scalars['String'];
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  recipientIds: Array<Scalars['String']>;
};


export type UserSummaryAnalyticsArgs = {
  courseId: Scalars['ID'];
};


export type UserTotalRecipientsArgs = {
  context?: InputMaybe<Scalars['String']>;
};


export type UserViewableSubmissionsConnectionArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filter?: InputMaybe<Array<Scalars['String']>>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for User. */
export type UserConnection = {
  __typename?: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type UserEdge = {
  __typename?: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

export type ValidationError = {
  __typename?: 'ValidationError';
  attribute?: Maybe<Scalars['String']>;
  message: Scalars['String'];
};

export type CourseQueryVariables = Exact<{
  courseId?: InputMaybe<Scalars['ID']>;
}>;


export type CourseQuery = { __typename?: 'Query', course?: { __typename?: 'Course', name: string, imageUrl?: any | null, modulesConnection?: { __typename?: 'ModuleConnection', nodes?: Array<{ __typename?: 'Module', name?: string | null, moduleItems?: Array<{ __typename?: 'ModuleItem', content?: { __typename: 'Assignment', id: string, title?: string | null } | { __typename: 'Discussion', id: string, title?: string | null } | { __typename: 'ExternalTool', title?: string | null } | { __typename: 'ExternalUrl', title?: string | null } | { __typename: 'File', id: string, contentType?: string | null, url?: any | null, title?: string | null } | { __typename: 'ModuleExternalTool' } | { __typename: 'Page', id: string, title?: string | null } | { __typename: 'Quiz' } | { __typename: 'SubHeader', title?: string | null } | null }> | null } | null> | null } | null } | null };

export type FileQueryVariables = Exact<{
  fileId: Scalars['ID'];
}>;


export type FileQuery = { __typename?: 'Query', node?: { __typename: 'Account' } | { __typename: 'Assignment' } | { __typename: 'AssignmentGroup' } | { __typename: 'AssignmentOverride' } | { __typename: 'CommentBankItem' } | { __typename: 'CommunicationChannel' } | { __typename: 'ContentTag' } | { __typename: 'Conversation' } | { __typename: 'Course' } | { __typename: 'Discussion' } | { __typename: 'DiscussionEntry' } | { __typename: 'Enrollment' } | { __typename: 'File', id: string, url?: any | null, displayName?: string | null } | { __typename: 'GradingPeriod' } | { __typename: 'Group' } | { __typename: 'GroupSet' } | { __typename: 'InternalSetting' } | { __typename: 'LearningOutcome' } | { __typename: 'LearningOutcomeGroup' } | { __typename: 'MediaObject' } | { __typename: 'MessageableContext' } | { __typename: 'MessageableUser' } | { __typename: 'Module' } | { __typename: 'ModuleItem' } | { __typename: 'Notification' } | { __typename: 'NotificationPolicy' } | { __typename: 'OutcomeCalculationMethod' } | { __typename: 'OutcomeFriendlyDescriptionType' } | { __typename: 'OutcomeProficiency' } | { __typename: 'Page' } | { __typename: 'PostPolicy' } | { __typename: 'Progress' } | { __typename: 'Quiz' } | { __typename: 'Rubric' } | { __typename: 'Section' } | { __typename: 'Submission' } | { __typename: 'Term' } | { __typename: 'User' } | null };


export const CourseDocument = gql`
    query course($courseId: ID) {
  course(id: $courseId) {
    name
    imageUrl
    modulesConnection {
      nodes {
        name
        moduleItems {
          content {
            __typename
            ... on Discussion {
              id
              title
            }
            ... on Assignment {
              id
              title: name
            }
            ... on File {
              id
              contentType
              url
              title: displayName
            }
            ... on ExternalTool {
              title: name
            }
            ... on SubHeader {
              title
            }
            ... on Page {
              id
              title
            }
            ... on ExternalUrl {
              title
            }
          }
        }
      }
    }
  }
}
    `;
export const FileDocument = gql`
    query file($fileId: ID!) {
  node(id: $fileId) {
    __typename
    ... on File {
      id
      url
      displayName
    }
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();
const CourseDocumentString = print(CourseDocument);
const FileDocumentString = print(FileDocument);
export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    course(variables?: CourseQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<{ data: CourseQuery; extensions?: any; headers: Dom.Headers; status: number; }> {
        return withWrapper((wrappedRequestHeaders) => client.rawRequest<CourseQuery>(CourseDocumentString, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'course', 'query');
    },
    file(variables: FileQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<{ data: FileQuery; extensions?: any; headers: Dom.Headers; status: number; }> {
        return withWrapper((wrappedRequestHeaders) => client.rawRequest<FileQuery>(FileDocumentString, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'file', 'query');
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;